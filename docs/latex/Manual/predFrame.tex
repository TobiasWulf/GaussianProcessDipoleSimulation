
% This LaTeX was auto-generated from MATLAB code.
% To make changes, update the MATLAB code and republish this document.

\documentclass{standalone}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage[framed, numbered]{matlab-prettifier}

\sloppy
\definecolor{lightgray}{gray}{0.5}
\setlength{\parindent}{0pt}

\begin{document}

    
    
\section*{predFrame}

\begin{par}
Predicts single test point and computes angle and radius by predicted sinoids. Delivers several quality criteria.
\end{par} \vspace{1em}

\subsection*{Contents}

\begin{itemize}
\setlength{\itemsep}{-1ex}
   \item Syntax
   \item Description
   \item Input Argurments
   \item Output Argurments
   \item Requirements
   \item See Also
\end{itemize}


\subsection*{Syntax}

\begin{lstlisting}[style=Matlab-editor]
[fang, frad, fcos, fsin, fcov, s, ciang, cirad] = predFrame(Mdl, Xcos, Xsin)
\end{lstlisting}


\subsection*{Description}

\begin{par}
\textbf{[fang, frad, fcos, fsin, fcov, s, ciang, cirad] = predFrame(Mdl, Xcos, Xsin)} predicts sinoids by passed regression model and test frame of raw data matrix. Comutes angle and radius by predicted results. Several quality creteria are setup based on predictive variance.
\end{par} \vspace{1em}


\subsection*{Input Argurments}

\begin{par}
\textbf{Mdl} model struct.
\end{par} \vspace{1em}
\begin{par}
\textbf{Xcos} matrix frame of cosine test data.
\end{par} \vspace{1em}
\begin{par}
\textbf{Xsin} matrix frame of sine test data.
\end{par} \vspace{1em}


\subsection*{Output Argurments}

\begin{par}
\textbf{fang} computed angle by predicted cosine and sine results.
\end{par} \vspace{1em}
\begin{par}
\textbf{frad} computed radius by predicted cosine and sine results.
\end{par} \vspace{1em}
\begin{par}
\textbf{fcos} predictive mean result of cosine regression.
\end{par} \vspace{1em}
\begin{par}
\textbf{fsin} predictive mean result of sine regression.
\end{par} \vspace{1em}
\begin{par}
\textbf{fcov} predictive variance for both predictive means.
\end{par} \vspace{1em}
\begin{par}
\textbf{s} resulting standard deviation by predictive variance and noise level.
\end{par} \vspace{1em}
\begin{par}
\textbf{ciang} confidence interval of computed angle.
\end{par} \vspace{1em}
\begin{par}
\textbf{cirad} confidence interval of computed radius.
\end{par} \vspace{1em}


\subsection*{Requirements}

\begin{itemize}
\setlength{\itemsep}{-1ex}
   \item Other m-files required: None
   \item Subfunctions: computeTransposeInverseProduct, sinoids2angles
   \item MAT-files required: None
\end{itemize}


\subsection*{See Also}

\begin{itemize}
\setlength{\itemsep}{-1ex}
   \item \begin{verbatim}computeTransposeInverseProduct\end{verbatim}
   \item \begin{verbatim}sinoids2angles\end{verbatim}
   \item \begin{verbatim}initKernel\end{verbatim}
   \item \begin{verbatim}initKernelParameters\end{verbatim}
\end{itemize}
\begin{par}
Created on November 06. 2019 by Klaus Juenemann. Copyright Klaus Juenemann 2019.
\end{par} \vspace{1em}
\begin{par}

\end{par} \vspace{1em}
\begin{lstlisting}[style=Matlab-editor]
function [fang, frad, fcos, fsin, fcov, s, ciang, cirad] = predFrame(Mdl, ...
    Xcos, Xsin)

    % adjust inputs if needed
    Xcos = Mdl.inputFun(Xcos);
    Xsin = Mdl.inputFun(Xsin);

    % compute covariance between observations and test point
    k = Mdl.kernelFun(Mdl.Xcos, Xcos, Mdl.Xsin, Xsin, Mdl.theta);

    % compute predictiv variance as the difference between test point covariance
    % which should be Mdl.theta(1) = s2f  product of the covariance between
    % observations and test points
    % compute the covariance of test point itself means distance is zero which
    % implies that result must be the variance s2f
    c1 = Mdl.kernelFun(Xcos, Xcos, Xsin, Xsin, Mdl.theta);
    % assert(c1 == Mdl.theta(1));

    % now add variance from additives
    fcov = c1 - computeTransposeInverseProduct(Mdl.L, k);

    % predict depending on model mean function
    switch Mdl.mean
        case 'zero'
             % compute the predictive means directly by covariance vector and
             % alpha weights, mean is zero
            fcos = k' * Mdl.AlphaCos;
            fsin = k' * Mdl.AlphaSin;
        case 'poly'
            % compute
            fcos = Mdl.meanFunCos(Xcos) + k' * Mdl.AlphaCos;
            fsin = Mdl.meanFunSin(Xsin) + k' * Mdl.AlphaSin;
        otherwise
            error('Unsupported mean function %s in prediction.', Mdl.mean);
    end

    % compute radius from sinoid results
    frad = sqrt(fcos^2 + fsin^2);

    % compute angle in rad from sinoid results
    fang = sinoids2angles(fsin, fcos, frad, true);

    % sigma of the normal distribution over fradius
    s = sqrt(fcov + Mdl.s2n);

    % 95% confidence interval over fradius
    ciang = [fang - asin(1.96 * s * sqrt(2)), fang + asin(1.96 * s * sqrt(2))];

    % 95% confidence interval over fradius
    cirad = [frad - 1.96 * s * sqrt(2), frad + 1.96 * s * sqrt(2)];
end
\end{lstlisting}



\end{document}

