
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>simulateDipoleSquareSensorArray</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-11-25"><meta name="DC.source" content="simulateDipoleSquareSensorArray.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>simulateDipoleSquareSensorArray</h1><!--introduction--><p>Simulate a sensor array of square shape with dipole magnet as stimulus. Needs options loaded from config file or generated from config generation script. Characterization data must be loaded befor and served as CharData struct. Loops throught positions saves a data set for every supported position of UseOptions which is called TrainingOptions or TestOptions in config.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Examples</a></li><li><a href="#4">Input Argurments</a></li><li><a href="#5">Output Argurments</a></li><li><a href="#6">Requirements</a></li><li><a href="#7">See Also</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, <span class="keyword">...</span>
    SensorArrayOptions, DipoleOptions, UseOptions, CharData)
</pre><h2 id="2">Description</h2><p><b>simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, ...    SensorArrayOptions, DipoleOptions, UseOptions, CharData)</b> saves simulation    datasets to data path specified in PathVariables and UseOptions.</p><h2 id="3">Examples</h2><pre class="language-matlab"><span class="comment">% load config from mat-file</span>
load(<span class="string">'config.mat'</span>, <span class="string">'GeneralOptions'</span>, <span class="string">'PathVariables'</span>, <span class="string">'SensorArrayOptions'</span>,
    <span class="string">'DipoleOptions'</span>, <span class="string">'TrainingOptions'</span>, <span class="string">'TestOptions'</span>);
</pre><pre class="language-matlab"><span class="comment">% load characteriazation dataset</span>
TDK = load(PathVariables.tdkDatasetPath);
</pre><pre class="language-matlab"><span class="comment">% generate training dataset(s)</span>
simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, <span class="keyword">...</span>
    SensorArrayOptions, DipoleOptions, TrainingOptions, TDK)
</pre><pre class="language-matlab"><span class="comment">% generate test dataset(s)</span>
simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, <span class="keyword">...</span>
    SensorArrayOptions, DipoleOptions, TestOptions, TDK)
</pre><h2 id="4">Input Argurments</h2><p><b>GeneralOptions</b> struct of general options generate by config script, includes date format and so on.</p><p><b>PathVariables</b> struct of project path generated by config script, includes data path for save and load data.</p><p><b>SensorArrayOptions</b> struct of sensor array shape and behavior generated by congig script.</p><p><b>DipoleOptions</b> struct of dipole specification, defines magnet and stimulus, generated by config script.</p><p><b>UseOptions</b> struct of implemetnation of use case, defines which kind of datset will be generated. At current state test and training dataset are available options in config. In config generated structs are TestOptions and TrainingOptions.</p><p><b>CharData</b> struct of characteriazation data. Therfore load characterization dataset as shown in examples into a struct.</p><h2 id="5">Output Argurments</h2><p><b>None</b></p><h2 id="6">Requirements</h2><div><ul><li>Other m-files required: computeDipoleH0Norm.m, computeDipoleHField.m,   genertateDipoleRotationMoments.m, generateSensorArraySquareGrid.m,   rotate3DVector.m</li><li>Subfunctions: reshape, interp2, sum</li><li>MAT-files required: config.mat, TDK_TAS2141_Characterization_2020-10-22_18-12-16-827.mat</li></ul></div><h2 id="7">See Also</h2><div><ul><li><a href="computeDipoleH0Norm.html">computeDipoleH0Norm</a></li><li><a href="computeDipoleHField.html">computeDipoleHField</a></li><li><a href="genertateDipoleRotationMoments.html">genertateDipoleRotationMoments</a></li><li><a href="generateSensorArraySquareGrid.html">generateSensorArraySquareGrid</a></li><li><a href="rotate3DVector.html">rotate3DVector</a></li></ul></div><p>Created on June 11. 2019 by Thorben Sch&uuml;the. Copyright Thorben Sch&uuml;the 2019.</p><p>
<!--
Hidden Clutter.
Edited on November 25. 2020 by Tobias Wulf: Rewrite scratch script from Thorben.
Edited on November 25. 2020 by Tobias Wulf: New dataset format.
Edited on November 25. 2020 by Tobias Wulf: Using interp2 nearest.
Edited on November 25. 2020 by Tobias Wulf: Using new written src functions.
Edited on November 25. 2020 by Tobias Wulf: Loop over a set of positions.
-->
</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% simulateDipoleSquareSensorArray
% Simulate a sensor array of square shape with dipole magnet as stimulus. Needs
% options loaded from config file or generated from config generation script.
% Characterization data must be loaded befor and served as CharData struct.
% Loops throught positions saves a data set for every supported position of
% UseOptions which is called TrainingOptions or TestOptions in config.
%
%
%% Syntax
%   simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, ...
%       SensorArrayOptions, DipoleOptions, UseOptions, CharData)
%
%
%% Description
% *simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, ...
%    SensorArrayOptions, DipoleOptions, UseOptions, CharData)* saves simulation
%    datasets to data path specified in PathVariables and UseOptions.
%
%% Examples
%   % load config from mat-file
%   load('config.mat', 'GeneralOptions', 'PathVariables', 'SensorArrayOptions',
%       'DipoleOptions', 'TrainingOptions', 'TestOptions');
%
%   % load characteriazation dataset
%   TDK = load(PathVariables.tdkDatasetPath);
%
%   % generate training dataset(s)
%   simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, ...
%       SensorArrayOptions, DipoleOptions, TrainingOptions, TDK)
%
%   % generate test dataset(s)
%   simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, ...
%       SensorArrayOptions, DipoleOptions, TestOptions, TDK)
%
%
%% Input Argurments
% *GeneralOptions* struct of general options generate by config script, includes
% date format and so on.
%
% *PathVariables* struct of project path generated by config script, includes
% data path for save and load data.
%
% *SensorArrayOptions* struct of sensor array shape and behavior generated by
% congig script.
%
% *DipoleOptions* struct of dipole specification, defines magnet and stimulus,
% generated by config script.
%
% *UseOptions* struct of implemetnation of use case, defines which kind of
% datset will be generated. At current state test and training dataset are
% available options in config. In config generated structs are TestOptions and
% TrainingOptions.
%
% *CharData* struct of characteriazation data. Therfore load characterization
% dataset as shown in examples into a struct.
%
%
%% Output Argurments
% *None*
%
%
%% Requirements
% * Other m-files required: computeDipoleH0Norm.m, computeDipoleHField.m,
%   genertateDipoleRotationMoments.m, generateSensorArraySquareGrid.m,
%   rotate3DVector.m
% * Subfunctions: reshape, interp2, sum
% * MAT-files required: config.mat, TDK_TAS2141_Characterization_2020-10-22_18-12-16-827.mat
%
%
%% See Also
% * <computeDipoleH0Norm.html computeDipoleH0Norm>
% * <computeDipoleHField.html computeDipoleHField>
% * <genertateDipoleRotationMoments.html genertateDipoleRotationMoments>
% * <generateSensorArraySquareGrid.html generateSensorArraySquareGrid>
% * <rotate3DVector.html rotate3DVector>
%
%
% Created on June 11. 2019 by Thorben Schüthe. Copyright Thorben Schüthe 2019.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on November 25. 2020 by Tobias Wulf: Rewrite scratch script from Thorben.
% Edited on November 25. 2020 by Tobias Wulf: New dataset format.
% Edited on November 25. 2020 by Tobias Wulf: Using interp2 nearest.
% Edited on November 25. 2020 by Tobias Wulf: Using new written src functions.
% Edited on November 25. 2020 by Tobias Wulf: Loop over a set of positions.
% REPLACE_WITH_DASH_DASH>
% </html>
%
function simulateDipoleSquareSensorArray(GeneralOptions, PathVariables, ...
    SensorArrayOptions, DipoleOptions, UseOptions, CharData)
    arguments
        % validate inputs as struct, structs generated in config.mat
        GeneralOptions struct {mustBeA(GeneralOptions, 'struct')}
        PathVariables struct {mustBeA(PathVariables, 'struct')}
        SensorArrayOptions struct {mustBeA(SensorArrayOptions, 'struct')}
        DipoleOptions struct {mustBeA(DipoleOptions, 'struct')}
        UseOptions struct {mustBeA(UseOptions, 'struct')}
        CharData struct {mustBeA(CharData, 'struct')}
    end
    
    % try to load relavant values in local variable space for better
    % handling and short names second check if struct fields are reachable
    try
        % general options needed to create filenames etc.
        dfStr = GeneralOptions.dateFormat;
                
        % number of sensors at edge of square array, dimension N x N
        N = SensorArrayOptions.dimension;
        % sensor array edge length, square edge a
        a = SensorArrayOptions.edge;
        % sensor array supply voltage used to generate bridge outputs from
        % characterization data in combination with bridge offset voltage
        % characterization data should be in mv/V so check norm factor
        Vcc = SensorArrayOptions.Vcc;
        Voff = SensorArrayOptions.Voff;
        Vnorm = SensorArrayOptions.Vnorm;
        switch CharData.Info.Units.SensorOutputVoltage
            case 'mV/V'
                if Vnorm ~= 1e3
                    error('Wrong norming mV/V: %e', Vnorm);
                end
            otherwise
                error('Unknown norm voltage: %s', ...
                    CharData.Info.Units.SensorOutputVoltage)
        end
        
        % sphere radius for dipole approximation of spherical magnet
        rsp = DipoleOptions.sphereRadius;
        % H-field magnitude to imprint in certain distance from magnet
        % surface which sphere radius rsp plus distance z0
        H0mag = DipoleOptions.H0mag;
        % distance from magnet surface where to imprint the H0mag
        z0 = DipoleOptions.z0;
        % magnetic dipole moment magnitude which define orgin moment of the
        % magnet in rest position
        M0mag = DipoleOptions.M0mag;
        
        % dataset type or use case in which later it is use in application
        useCase = UseOptions.useCase;
        % destination path and filename to save gernerated data sets with
        % timestamps in filename, place timestamps with sprintf
        switch useCase
            case 'Training'
                dpStr = fullfile(PathVariables.trainingDataPath, ...
                    'Training_%s.mat');
            case 'Test'
                dpStr = fullfile(PathVariables.testDataPath, 'Test_%s.mat');
            otherwise
                error('Unknown use case: %s', UseOptions.useCase);
        end
        % x, y and z positions in which pairing the datasets are generated
        % position vectors are run through in all combinations with tilt
        % and number of angles
        xPos = UseOptions.xPos;
        yPos = UseOptions.yPos;
        zPos = UseOptions.zPos;
        tilt = UseOptions.tilt;
        nAngles = UseOptions.nAngles;
        % constants for generated use case, angle resolution for generated
        % rotation angles, phase index for a phase shift in generation of
        % rotation angles
        angleRes = UseOptions.angleRes;
        phaseIndex = UseOptions.phaseIndex;
        % which characterization reference should be load from CharData
        % sensor output bridge fields (cos/sin)
        refImage = UseOptions.BridgeReference;
        
        % load values from characterization dataset
        % scales of driven Hx and Hy amplitudes in characteriazation
        % stimulus in kA/m
        if ~strcmp(CharData.Info.Units.MagneticFieldStrength, 'kA/m')
            error('Wrong H-field unit: %s', ...
                CharData.Info.Units.MagneticFieldStrength);
        end
        HxScale = CharData.Data.MagneticField.hx;
        HyScale = CharData.Data.MagneticField.hy;
        % cosinus and sinus characterization images for corresponding field
        % amplitudes, load and norm to Vcc and Voff, references of
        % simulation
        VcosRef = CharData.Data.SensorOutput.CosinusBridge.(refImage) .* (Vcc / Vnorm) + Voff;
        VsinRef = CharData.Data.SensorOutput.SinusBridge.(refImage) .* (Vcc / Vnorm) + Voff;
    catch ME
        rethrow(ME)
    end
    
    % now everything is successfully loaded, execute further constants
    % which are needs to be generated once for all following operations
    % meshgrids for refernece images to query bridge reference with interp2
    [HxScaleGrid, HyScaleGrid] = meshgrid(HxScale, HyScale);
    % allocate memory for results of on setup run, speed up compute by 10
    % fix allocations which are not changing by varring parameters like
    % number of angles or positon, for all parameter depended memory size
    % allocalte matlab automatically by function call or need reallocation
    % in for loops
    % H-field components for each rotation step
    Hx = zeros(N, N, nAngles);
    Hy = zeros(N, N, nAngles);
    Hz = zeros(N, N, nAngles);
    % H-field abs for each rotation setp
    Habs = zeros(N, N, nAngles);
    % Bridge output voltages for each sensor in grid, H-fields, sensor
    % grid, voltages all same orientation
    Vcos = zeros(N, N, nAngles);
    Vsin = zeros(N, N, nAngles);
    
    
    % compute values which not changing by loop parameters
    % magnetic dipole moments for each rotation step
    % rotation angles to compute
    % index corresponding to full scale rotation with angleRes  
    [m, angles, angleRefIndex] = generateDipoleRotationMoments(M0mag, ...
        nAngles, tilt, angleRes, phaseIndex);
    
    % rotation angle step width on full rotation 360° with subset of angles
    if length(angles) > 1
        angleStep =  angles(2) - angles(1);
    else 
        angleStep = 0;
    end
    
    % compute dipole rest position norm to imprint a certain field
    % strength magnitude with respect of tilt in y axes and magnetization
    % in x direction as in generate Dipole rotation moments
    r0 = rotate3DVector([0; 0; -(z0 + rsp)], 0, tilt, 0);
    m0 = rotate3DVector([-M0mag; 0; 0], 0, tilt, 0);
    H0norm = computeDipoleH0Norm(H0mag, m0, r0);
    
    % prepare file header Info struct, overwrite certain fields in loop like x,
    % y, z positions
    Info = struct;
    Info.SensorArrayOptions = SensorArrayOptions;
    Info.SensorArrayOptions.SensorCount = N^2;
    Info.DipoleOptions = DipoleOptions;
    Info.UseOptions = UseOptions;
    Info.CharData = join([CharData.Info.SensorManufacturer, CharData.Info.Sensor]);
    Info.Units.SensorOutputVoltage = 'V';
    Info.Units.MagneticFieldStrength = 'kA/m';
    Info.Units.Angles = 'degree';
    Info.Units.Length = 'mm';
    
    % collect relevant to Data struct for save to file with file
    % header Info struct, overwrite position depended fields in loop before save
    Data = struct;
    Data.HxScale = HxScale;
    Data.HyScale = HyScale;
    Data.VcosRef = VcosRef;
    Data.VsinRef = VsinRef;
    Data.r0 = r0;
    Data.m0 = m0;
    Data.H0norm = H0norm;
    Data.m = m;
    Data.angles = angles;
    Data.angleStep = angleStep;
    Data.angleRefIndex = angleRefIndex;
    
    % generate dataset for all use case setup pairs in for loop and append
    % generated dataset path to path struct for result
    % outer to inner loop is positions to angles
    % generate z layer wise
    for z = zPos 
        for x = xPos
            for y = yPos
                % generate sensor array grid according to current position
                % current position vector of sensor array relative to
                % magnet surface
                p = [x; y; z];
                % write current position in file header
                Info.UseOptions.xPos = x;
                Info.UseOptions.yPos = y;
                Info.UseOptions.zPos = z;
                % sensor array grid coordinates
                [X, Y, Z] = generateSensorArraySquareGrid(N, a, p, rsp);
                % save current sensor gird to Data struct
                Data.X = X;
                Data.Y = Y;
                Data.Z = Z;
                for i = 1:nAngles
                    % calculate H-field of one rotation step for all
                    % positions, the field is normed to zero position
                    H = computeDipoleHField(X, Y, Z, m(:,i), H0norm);
                    % separate parts or field in axes direction/ components
                    Hx(:,:,i) = reshape(H(1,:), N, N);
                    Hy(:,:,i) = reshape(H(2,:), N, N);
                    Hz(:,:,i) = reshape(H(2,:), N, N);
                    Habs(:,:,i) = reshape(sqrt(sum(H.^2, 1)), N, N);
                    % get bridge outputs from references by cross pick
                    % references from grid, the Hx and Hy queries can be
                    % served as matrix as long they have same size and
                    % orientation the nearest neigbhor interpolation
                    % returns of same size and related to orientation, for
                    % outlayers return NaN, do this for every angle
                    Vcos(:,:,i) = interp2(HxScaleGrid, HyScaleGrid, VcosRef, ...
                        Hx(:,:,i), Hy(:,:,i), 'nearest', NaN);
                    Vsin(:,:,i) = interp2(HxScaleGrid, HyScaleGrid, VsinRef, ...
                        Hx(:,:,i), Hy(:,:,i), 'nearest', NaN);
                end % angles
                % save rotation results to Data struct
                Data.Hx = Hx;
                Data.Hy = Hy;
                Data.Hz = Hz;
                Data.Habs = Habs;
                Data.Vcos = Vcos;
                Data.Vsin = Vsin;
                % save results to file 
                filePath = sprintf(dpStr, datestr(now(), dfStr));
                Info.filePath = filePath;
                disp(filePath)
                save(filePath, 'Info', 'Data', '-v7.3', '-nocompression');
            end % y 
        end % x
    end % z
end


##### SOURCE END #####
--></body></html>