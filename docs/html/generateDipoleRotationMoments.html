
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>generateDipoleRotationMoments</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-12-09"><meta name="DC.source" content="generateDipoleRotationMoments.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>generateDipoleRotationMoments</h1><!--introduction--><p>Generate magnetic moments to perform a full rotation of a magnetic dipole in the z-axes with a certain tilt. The moments covers a rotation from 0&deg; to 360&deg; and are eqaul distributed between 0&deg; and 360&deg;. 0&deg; and 360&deg; are related to the first moment which is representated by the start vector of</p><p><img src="generateDipoleRotationMoments_eq14695475173459055334.png" alt="$$\vec{m_0} = |m_0| \cdot \left[ \matrix{-1 \cr 0 \cr 0} \right]$$"></p><p>Due to the start vecotor position the tilt of z-axes must be applied with a tilt angle in y-axes. So the rotated vector of the start moment is described by</p><p><img src="generateDipoleRotationMoments_eq17772099022281998200.png" alt="$$\vec{m_i} = R_z(\theta_i) R_y(\phi) R_x(0^{\circ}) \vec{m_0}$$"></p><p>The returning Moments matrix is 3 x N matrix where each moment vector</p><p><img src="generateDipoleRotationMoments_eq02185073220095253637.png" alt="$$\vec{M} = \left[ \vec{m_i} \cdots \vec{m_N} \right]$$"></p><p>corresponds to a i-th angle in 1 x N thetas vector.</p><p><img src="generateDipoleRotationMoments_eq10853035796944828668.png" alt="$$\vec{\theta} = \left[ \theta_i \cdots \theta_N \right]$$"></p><p>for</p><p><img src="generateDipoleRotationMoments_eq10011606457112371591.png" alt="$$i = 1 \cdots N$$"></p><p>The resolution of the angles can be modified additionally. At first the full angle vector theta is fully generated with given resolution and downsampled afterwards to the defined number of angles. On the resultating theta vector is base of magnetical moments.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Examples</a></li><li><a href="#4">Input Arguments</a></li><li><a href="#5">Output Arguments</a></li><li><a href="#6">Requirements</a></li><li><a href="#7">See Also</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">M = generateDipoleRotationMoments(m0, nTheta)
[M, thetas] = generateDipoleRotationMoments(m0, nTheta)
[M, thetas] = generateDipoleRotationMoments(m0, nTheta, phi)
[M, thetas] = generateDipoleRotationMoments(m0, nTheta, phi, resolution)
[M, thetas, index] = generateDipoleRotationMoments(m0, nTheta, phi, resolution, phaseIndex)
</pre><h2 id="2">Description</h2><p><b>M = generateDipoleRotationMoments(m0, nTheta)</b> generate magnetic moments for N numbers of rotation angles theta in 3 x N sized matrix. With a default angle resoulution of 1&deg; and a start angle of 0&deg;.</p><p><b>[M, theta] = generateDipoleRotationMoments(m0, nTheta)</b> returns so magnetic moments as before and related angles theta as 1 x N vector.</p><p><b>[M, theta] = generateDipoleRotationMoments(m0, nTheta, phi)</b> generate magnetic moments for a rotation with a tilt angle phi.</p><p><b>[M, theta] = generateDipoleRotationMoments(m0, nTheta, phi, resolution)</b> return moments and angles like described above but with given resolution in degree. The resolution is used in generation of full scale rotation angle base and sometime not visible in the output caused by the number of angles. So which angle are even picked from full scale rotation to compute a down sampled set of angles.</p><p><b>[M, theta, index] = generateDipoleRotationMoments(m0, nTheta, phi, resolution, phaseIndex)</b> returns the moments, the angles and index reprensetation of down sampled angles in the full scale rotation vectort.</p><h2 id="3">Examples</h2><pre class="language-matlab"><span class="comment">% choose a huge moment amplitude to withdraw numeric erros in later H-field</span>
<span class="comment">% strength calculations</span>
m0 = 1e6;
</pre><pre class="language-matlab"><span class="comment">% get a full scale (FS) rotation of with 0.5&deg; resolution and no tilt</span>
[MFS, thetaFS] = generateDipolRotationMoments(m0, 0, 0, 0.5);
</pre><pre class="language-matlab"><span class="comment">% get down sampled (DS) rotation with equal distanced angles of the same full</span>
<span class="comment">% scale and refered index to the full scale. 8 angles.</span>
[MDS, thetaDS, iFS] = generateDipolRotationMoments(m0, 8, 0, 0.5);
</pre><pre class="language-matlab"><span class="comment">% check distribution to full scale must be true if distribution is correct</span>
all(MFS(iFS) == MDS)
all(thetaFS(iFS) == thetaDS)
</pre><pre class="language-matlab"><span class="comment">% now shift the sample pick by 22 samples (11&deg; with resolution of 0.5&deg;)</span>
[MDSS, thetaDSS] = generateDipolRotationMoments(m0, 8, 0, 0.5, 22);
</pre><pre class="language-matlab"><span class="comment">% check with index shift by 22 in iFS index</span>
all(MFS(iFS + 22) == MDSS)
all(thetaFS(iFS + 22) == thetaDSS)
</pre><h2 id="4">Input Arguments</h2><p><b>m0</b> scalar value of magnetic moment magnitude. Choose huge value to prevent numeric failures in later field strength calculation. 1e6 is a proven value. The is later normated in the field calculation process. Can be any real number.</p><p><b>nTheat</b> scalar value and number of angles which are even picked from the full rotation to produce smaller rotatation datasets. Must be a positive integer or zero. If zero the full scale rotation is returned.</p><p><b>phi</b> scalar angule in degree to tilt the z-axes of the rotation. Can be any real number. Default is 0&deg;.</p><p><b>resolution</b> scalar angle resolution must be real positive number and probably smaller than 360&deg;. Default is 1&deg;.</p><p><b>phaseIndex</b> scalar integer number to shift the start index of down sampling the full scale rotation. Therfore nTheta must be greater than 0. Default is 0.</p><h2 id="5">Output Arguments</h2><p><b>M</b> matrix of magnetic moments related to vector theta. Matrix of size 3 x N.</p><p><b>theta</b> related angles to calculated magnetic moments in a row vector of size 1 x N.</p><p><b>index</b> reference to full scale angle vector. Empty if nTheta is zero and theta is the full scale vector.</p><h2 id="6">Requirements</h2><div><ul><li>Other m-files required: rotate3DVector.m</li><li>Subfunctions: length, downsample, ismember, find</li><li>MAT-files required: None</li></ul></div><h2 id="7">See Also</h2><div><ul><li><a href="rotate3DVector.html">rotate3DVector</a></li><li><a href="matlab:web(fullfile(docroot,'signal/ref/downsample.html'))">downsample</a></li><li><a href="matlab:web(fullfile(docroot,'matlab/ref/double.ismember.html'))">ismember</a></li><li><a href="matlab:web(fullfile(docroot,'matlab/ref/find.html'))">find</a></li></ul></div><p>Created on November 06. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.</p><p>
<!--
Hidden Clutter.
Edited on Month DD. YYYY by Editor: Single line description.
-->
</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% generateDipoleRotationMoments
% Generate magnetic moments to perform a full rotation of a magnetic dipole in
% the z-axes with a certain tilt. The moments covers a rotation from 0° to 360°
% and are eqaul distributed between 0° and 360°. 0° and 360° are related to the
% first moment which is representated by the start vector of
%
% $$\vec{m_0} = |m_0| \cdot \left[ \matrix{-1 \cr 0 \cr 0} \right]$$
% 
% Due to the start vecotor position the tilt of z-axes must be applied with a
% tilt angle in y-axes. So the rotated vector of the start moment is described
% by
%
% $$\vec{m_i} = R_z(\theta_i) R_y(\phi) R_x(0^{\circ}) \vec{m_0}$$
%
% The returning Moments matrix is 3 x N matrix where each moment vector
%
% $$\vec{M} = \left[ \vec{m_i} \cdots \vec{m_N} \right]$$
%
% corresponds to a i-th angle in 1 x N thetas vector.
%
% $$\vec{\theta} = \left[ \theta_i \cdots \theta_N \right]$$
%
% for
%
% $$i = 1 \cdots N$$
%
% The resolution of the angles can be modified additionally. At first the full
% angle vector theta is fully generated with given resolution and downsampled
% afterwards to the defined number of angles. On the resultating theta vector is
% base of magnetical moments.
%
%
%% Syntax
%   M = generateDipoleRotationMoments(m0, nTheta)
%   [M, thetas] = generateDipoleRotationMoments(m0, nTheta)
%   [M, thetas] = generateDipoleRotationMoments(m0, nTheta, phi)
%   [M, thetas] = generateDipoleRotationMoments(m0, nTheta, phi, resolution)
%   [M, thetas, index] = generateDipoleRotationMoments(m0, nTheta, phi, resolution, phaseIndex)
%
%
%% Description
% *M = generateDipoleRotationMoments(m0, nTheta)* generate magnetic moments
% for N numbers of rotation angles theta in 3 x N sized matrix. With a default
% angle resoulution of 1° and a start angle of 0°.
%
% *[M, theta] = generateDipoleRotationMoments(m0, nTheta)* returns so
% magnetic moments as before and related angles theta as 1 x N vector.
%
% *[M, theta] = generateDipoleRotationMoments(m0, nTheta, phi)* generate
% magnetic moments for a rotation with a tilt angle phi.
%
% *[M, theta] = generateDipoleRotationMoments(m0, nTheta, phi, resolution)*
% return moments and angles like described above but with given resolution in
% degree. The resolution is used in generation of full scale rotation angle base
% and sometime not visible in the output caused by the number of angles. So
% which angle are even picked from full scale rotation to compute a down sampled
% set of angles.
% 
% *[M, theta, index] = generateDipoleRotationMoments(m0, nTheta, phi, resolution, phaseIndex)*
% returns the moments, the angles and index reprensetation of down sampled
% angles in the full scale rotation vectort.
%
%
%% Examples
%   % choose a huge moment amplitude to withdraw numeric erros in later H-field
%   % strength calculations
%   m0 = 1e6;
%
%   % get a full scale (FS) rotation of with 0.5° resolution and no tilt
%   [MFS, thetaFS] = generateDipolRotationMoments(m0, 0, 0, 0.5);
%
%   % get down sampled (DS) rotation with equal distanced angles of the same full
%   % scale and refered index to the full scale. 8 angles.
%   [MDS, thetaDS, iFS] = generateDipolRotationMoments(m0, 8, 0, 0.5);
%  
%   % check distribution to full scale must be true if distribution is correct
%   all(MFS(iFS) == MDS)
%   all(thetaFS(iFS) == thetaDS)
%
%   % now shift the sample pick by 22 samples (11° with resolution of 0.5°)
%   [MDSS, thetaDSS] = generateDipolRotationMoments(m0, 8, 0, 0.5, 22);
%
%   % check with index shift by 22 in iFS index
%   all(MFS(iFS + 22) == MDSS)
%   all(thetaFS(iFS + 22) == thetaDSS)
%  
%
%% Input Arguments
% *m0* scalar value of magnetic moment magnitude. Choose huge value to
% prevent numeric failures in later field strength calculation. 1e6 is a proven
% value. The is later normated in the field calculation process. Can be any real
% number.
%
% *nTheat* scalar value and number of angles which are even picked from the full
% rotation to produce smaller rotatation datasets. Must be a positive integer or
% zero. If zero the full scale rotation is returned.
%
% *phi* scalar angule in degree to tilt the z-axes of the rotation. Can be any
% real number. Default is 0°.
%
% *resolution* scalar angle resolution must be real positive number and probably
% smaller than 360°. Default is 1°.
%
% *phaseIndex* scalar integer number to shift the start index of down sampling
% the full scale rotation. Therfore nTheta must be greater than 0. Default is 0.
%
%
%% Output Arguments
% *M* matrix of magnetic moments related to vector theta. Matrix of size 3 x N.
%
% *theta* related angles to calculated magnetic moments in a row vector of size
% 1 x N.
%
% *index* reference to full scale angle vector. Empty if nTheta is zero and
% theta is the full scale vector.
%
%
%% Requirements
% * Other m-files required: rotate3DVector.m
% * Subfunctions: length, downsample, ismember, find
% * MAT-files required: None
%
%
%% See Also
% * <rotate3DVector.html rotate3DVector>
% * <matlab:web(fullfile(docroot,'signal/ref/downsample.html')) downsample>
% * <matlab:web(fullfile(docroot,'matlab/ref/double.ismember.html')) ismember>
% * <matlab:web(fullfile(docroot,'matlab/ref/find.html')) find>
%
%
% Created on November 06. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on Month DD. YYYY by Editor: Single line description.
% REPLACE_WITH_DASH_DASH>
% </html>
%
function [M, theta, index] = generateDipoleRotationMoments(m0, nTheta, ...
    phi, resolution, phaseIndex)
    arguments
        % validate amplitude of magnetic moment as real scalar value
        m0 (1,1) double {mustBeReal}
        % validate number of used angulars as positive integer, for 0 return all
        nTheta (1,1) double {mustBeNonnegative, mustBeInteger}
        % validate tilt angle as real value with default 0°
        phi (1,1) double {mustBeReal} = 0
        % validate angle resolution as real positive value
        resolution (1,1) double {mustBePositive} = 1
        % validate downsample phase as positive integer with default 0, no shift
        phaseIndex (1,1) double {mustBeNonnegative, mustBeInteger} = 0
    end
    
    % scale full rotation angle vector with given resolution from 0° to 360°
    % so run to 360°-resolution because 0° == 360°, its a circle
    fullScale = 0:resolution:(360 - resolution);
    
    % if nThetas is greater than 0 downsample to nTheta else use full scale
    if nTheta
        % get equal distribute distance of samples in thetas for nThetas
        sampleDistance = length(downsample(fullScale, nTheta));
    
        % downsample with equal sample distance and passed sample phase to shift
        % first sample in downsample vector from 1 to phaseIndex
        theta = downsample(fullScale, sampleDistance, phaseIndex);
        
        % find index members of down sampled angles in full scale vector
        members = ismember(fullScale, theta);
        index = find(members);
        
    else
        % 0 is given for number of theta so it returns the full scale rotation
        % no index relations if full scale is returned
        nTheta = length(fullScale);
        theta = fullScale;
        index = [];
    end
    
    % create start moment with given magnetic moment amplitude basic moment to
    % produce rotate moments
    m0 = m0 * [-1; 0; 0];
    
    % allocate memory for the moments Matrix of rotated basic moments by i-th
    % theta and fixed tilt of phi and rotate of theta angulars
    M = zeros(3, nTheta);
    for i = 1:nTheta
        M(:,i) = rotate3DVector(m0, 0, phi, theta(i));
    end
end


##### SOURCE END #####
--></body></html>