
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: {extensions: ["mhchem.js"]},
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: true
            },
            CommonHTML: {minScaleAdjust: 110,},
            "HTML-CSS": {
                availableFonts: ["TeX"],
                scale: 110
            }
        });
        MathJax.Hub.Queue(["Rerender", MathJax.Hub], function () {window.status="finished"});
    </script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>computeOptimCriteria</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-05-14"><meta name="DC.source" content="computeOptimCriteria.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>computeOptimCriteria</h1><!--introduction--><p>Object function to compute the loss of a fully initialized and tuned regression model. Computes the mean std. log. loss of angles MSLLA or radius MSLLR as function evaluation value for bayesopt. Perform noise adjustment in cylces in bayesopt.</p><!--/introduction--><h2 id="1">Syntax</h2><pre class="language-matlab">MSLL = computeOptimCriteria(OptVar, Mdl, TestDS, SLL, verbose)
</pre><h2 id="2">Description</h2><p><b>MSLL = computeOptimCriteria(OptVar, Mdl, TestDS, SLL, verbose)</b></p><h2 id="3">Input Argurments</h2><p><b>OptVar</b> optimzation variable. Noise level passed by bayesopt algorithm.</p><p><b>Mdl</b> model struct.</p><p><b>TestDS</b> loaded test data by infront processesed sensor array simulation.</p><p><b>SLL</b> indicates which loss is used for MSLL. SLLA for angle and SLLR for radius.</p><p><b>verbose</b> activates prompt for true or 1. Vice versa for false or 0.</p><h2 id="4">Output Argurments</h2><p><b>MSLL</b> mean standardized logarithmic loss. Function evaluation value for optimGPR</p><h2 id="5">Requirements</h2><div><ul><li>Other m-files required: None</li><li>Subfunctions: tuneKernel, lossDS, mean</li><li>MAT-files required: None</li></ul></div><h2 id="6">See Also</h2><div><ul><li><a href="optimGPR.html">optimGPR</a></li><li><a href="tuneKernel.html">tuneKernel</a></li><li><a href="lossDS.html">lossDS</a></li><li><a href="matlab:web(fullfile(docroot,'matlab/ref/mean.html'))">mean</a></li></ul></div><p>Created on March 05. 2021 by Tobias Wulf. Copyright Tobias Wulf 2021.</p><p>
<!--
Hidden Clutter.
Edited on Month DD. YYYY by Editor: Single line description.
-->
</p><pre class="codeinput"><span class="keyword">function</span> MSLL = computeOptimCriteria(OptVar, Mdl, TestDS, SLL, verbose)

    <span class="comment">% push current variance value into GPR</span>
    Mdl.s2n = OptVar.s2n;

    <span class="comment">% tune kernel with new noise variance</span>
    Mdl = tuneKernel(Mdl, verbose);

    <span class="comment">% get loss on dataset for angular prediction</span>
    <span class="keyword">switch</span> SLL
        <span class="keyword">case</span> <span class="string">'SLLA'</span>
            [~, SLL] = lossDS(Mdl, TestDS);

        <span class="keyword">case</span> <span class="string">'SLLR'</span>
            [~, ~, SLL] = lossDS(Mdl, TestDS);

        <span class="keyword">otherwise</span>
            error(<span class="string">'Unknown SLL %s.'</span>, SLL);
    <span class="keyword">end</span>

    <span class="comment">% return mean loss to evaluate optimization run</span>
    MSLL = mean(SLL);
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% computeOptimCriteria
% Object function to compute the loss of a fully initialized and tuned
% regression model. Computes the mean std. log. loss of angles MSLLA or radius
% MSLLR as function evaluation value for bayesopt. Perform noise adjustment in
% cylces in bayesopt.
%
%
%% Syntax
%   MSLL = computeOptimCriteria(OptVar, Mdl, TestDS, SLL, verbose)
%
%
%% Description
% *MSLL = computeOptimCriteria(OptVar, Mdl, TestDS, SLL, verbose)* 
%
%
%% Input Argurments
% *OptVar* optimzation variable. Noise level passed by bayesopt algorithm.
%
% *Mdl* model struct.
%
% *TestDS* loaded test data by infront processesed sensor array simulation.
%
% *SLL* indicates which loss is used for MSLL. SLLA for angle and SLLR for
% radius.
%
% *verbose* activates prompt for true or 1. Vice versa for false or 0.
%
%
%% Output Argurments
% *MSLL* mean standardized logarithmic loss. Function evaluation value for
% optimGPR
%
%
%% Requirements
% * Other m-files required: None
% * Subfunctions: tuneKernel, lossDS, mean
% * MAT-files required: None
%
%
%% See Also
% * <optimGPR.html optimGPR>
% * <tuneKernel.html tuneKernel>
% * <lossDS.html lossDS>
% * <matlab:web(fullfile(docroot,'matlab/ref/mean.html')) mean>
%
%
% Created on March 05. 2021 by Tobias Wulf. Copyright Tobias Wulf 2021.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on Month DD. YYYY by Editor: Single line description.
% REPLACE_WITH_DASH_DASH>
% </html>
%
function MSLL = computeOptimCriteria(OptVar, Mdl, TestDS, SLL, verbose)
    
    % push current variance value into GPR
    Mdl.s2n = OptVar.s2n;
    
    % tune kernel with new noise variance
    Mdl = tuneKernel(Mdl, verbose);
    
    % get loss on dataset for angular prediction
    switch SLL
        case 'SLLA'
            [~, SLL] = lossDS(Mdl, TestDS);
            
        case 'SLLR'
            [~, ~, SLL] = lossDS(Mdl, TestDS);
            
        otherwise
            error('Unknown SLL %s.', SLL);
    end
    
    % return mean loss to evaluate optimization run
    MSLL = mean(SLL);
end
##### SOURCE END #####
--></body></html>