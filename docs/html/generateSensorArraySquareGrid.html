
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>generateSensorSquareArrayGrid</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-11-13"><meta name="DC.source" content="generateSensorArraySquareGrid.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>generateSensorSquareArrayGrid</h1><!--introduction--><p>Generate a position grid of sensors in x, y and z dimension. So the function returns a grid in shape of a square in which all sensors have even distances to each and another in x and y direction z is constant due to that all sensor are in the same distance to the .</p><p>The size of the sensor array is described by its edge length a</p><p><img src="generateSensorArraySquareGrid_eq15646403293203809680.png" alt="$$A = a^2$$"></p><p>and the distance d of each coordinate to the next point in x and y direction</p><p><img src="generateSensorArraySquareGrid_eq18234882407082815552.png" alt="$$d = \frac{a}{N-1}$$"></p><p>The coordinates of the array are scale from center of the square. So for the upper left corner position is described by</p><p><img src="generateSensorArraySquareGrid_eq04766331406166681700.png" alt="$$x_{1,1} = -\frac{a}{2} \quad y_{1,1} = -\frac{a}{2} \quad z = const.$$"></p><p>The coodinates of each dimension are placed in matrices of size N x N related to the number of sensors at one edge of the square Array. So position pattern in x dimension are returned as</p><p><img src="generateSensorArraySquareGrid_eq00940868007958350255.png" alt="$$X_0 = \left[ \matrix{x_{1,1} &amp; \cdots &amp; x_{1,N} \cr&#xA;                     \vdots  &amp; \ddots &amp; \vdots  \cr&#xA;                     x_{N,1} &amp; \cdots &amp; x_{N,N}} \right]$$"></p><p><img src="generateSensorArraySquareGrid_eq14796959324621073533.png" alt="$$x_{i,j} = x_{1,1} + j \cdot d - d$$"></p><p>same wise for y dimension but transposed</p><p><img src="generateSensorArraySquareGrid_eq04789365383809860529.png" alt="$$Y_0 = \left[ \matrix{y_{1,1} &amp; \cdots &amp; y_{1,N} \cr&#xA;                     \vdots  &amp; \ddots &amp; \vdots  \cr&#xA;                     y_{N,1} &amp; \cdots &amp; y_{N,N}} \right]$$"></p><p><img src="generateSensorArraySquareGrid_eq13721068922515636478.png" alt="$$y_{i,j} = y_{1,1} + i \cdot d - d$$"></p><p><img src="generateSensorArraySquareGrid_eq03555985756430632476.png" alt="$$Y_0 = X_0^T$$"></p><p>and z dimension</p><p><img src="generateSensorArraySquareGrid_eq06139028887598262814.png" alt="$$Z_0 = \left[ \matrix{z_{1,1} &amp; \cdots &amp; z_{1,N} \cr&#xA;                     \vdots  &amp; \ddots &amp; \vdots  \cr&#xA;                     z_{N,1} &amp; \cdots &amp; z_{N,N}} \right]$$"></p><p><img src="generateSensorArraySquareGrid_eq13967691963996651024.png" alt="$$z_{i,j} = 0$$"></p><p>for</p><p><img src="generateSensorArraySquareGrid_eq17629341197877401447.png" alt="$$i = 1, 2, \ldots, N \quad j = 1, 2, \ldots, N$$"></p><p>A relative position shift can be performed by pass a postion vector p with relativ position to center</p><p><img src="generateSensorArraySquareGrid_eq11158090870865863453.png" alt="$$\vec{p} = \left[ \matrix{ x_p \cr y_p \cr z_p} \right]$$"></p><p>So that a left shift in x and a up shift in y direction is performed by egativ values in p. To gain distance in z from center point so that center is above the sensor array increase the z positive. In addition to the z shift an offset r sphere can be set. The offset represents the radius of a sphere magnet in which center the dipole is placed. The dipole is placed in the center of the coordinate system and sensor array position is relative to the dipole or center. So shifts are described by</p><p><img src="generateSensorArraySquareGrid_eq00049857175735723296.png" alt="$$X = X_0 + x_p \quad Y = Y_0 + y_p \quad Z = Z_0 -(z_p + r_{sp})$$"></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Examples</a></li><li><a href="#4">Input Argurments</a></li><li><a href="#5">Output Argurments</a></li><li><a href="#6">Requirements</a></li><li><a href="#7">See Also</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">[X, Y, Z] = generateSensorArrayGrid(N, a, p, r)
</pre><h2 id="2">Description</h2><p><b>[X, Y, Z] = generateSensorArrayGrid(N, a, p, r)</b> returns a sensor array grid of size N x N with grid position matrices for x, y and z positions of each sensor in the array.</p><h2 id="3">Examples</h2><pre class="language-matlab"><span class="comment">% generate a grid of 8 x 8 sensors with no shift in x or y direction</span>
and <span class="string">a</span> <span class="string">static</span> <span class="string">position</span> <span class="string">of</span> <span class="string">4mm</span> <span class="string">under</span> <span class="string">the</span> <span class="string">center</span> <span class="string">in</span> <span class="string">z</span> <span class="string">dimension</span> <span class="string">with</span> <span class="string">a</span>
z <span class="string">offset</span> <span class="string">of</span> <span class="string">2mm</span> <span class="string">so</span> <span class="string">(2 + 2)mm</span>
N = 8;
p = [0, 0, 2]
r = 2;
[X, Y, Z] = generateSensorArrayGrid(N, a, p, r);
</pre><pre class="language-matlab"><span class="comment">% same layer but left shift by 2mm and down shift in y by 1mm</span>
p = [-2, 1, 2]
r = 2;
[X, Y, Z] = generateSensorArrayGrid(N, a, p, r);
</pre><h2 id="4">Input Argurments</h2><p><b>N</b> positive integer scalar number of sensors at one edge of the square grid. So the resulting grid has dimensions N x N.</p><p><b>a</b> positive real scalar value of sensor array edge length.</p><p><b>p</b> relative position vector, relative sensor array postion to center of the array. Place the array in 3D coorodinate system relative to the center of system.</p><p><b>r</b> positive real scalar is offset in z dimension and represents the sphere radius in which center the magnetic dipole is placed.</p><h2 id="5">Output Argurments</h2><p><b>X</b> x coordinates for each sensor in N x N matrix where each point has the same orientation as in y and z dimension.</p><p><b>Y</b> y coordinates for each sensor in N x N matrix where each point has the same orientation as in x and z dimension.</p><p><b>Z</b> z coordinates for each sensor in N x N matrix where each point has the same orientation as in x and y dimension.</p><h2 id="6">Requirements</h2><div><ul><li>Other m-files required: None</li><li>Subfunctions: meshgrid</li><li>MAT-files required: None</li></ul></div><h2 id="7">See Also</h2><div><ul><li><a href="matlab:web(fullfile(docroot,'matlab/ref/meshgrid.html'))">meshgrid</a></li></ul></div><p>Created on November 10. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.</p><p>
<!--
Hidden Clutter.
Edited on Month DD. YYYY by Editor: Single line description.
-->
</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% generateSensorSquareArrayGrid
% Generate a position grid of sensors in x, y and z dimension. So the
% function returns a grid in shape of a square in which all sensors have 
% even distances to each and another in x and y direction z is constant due
% to that all sensor are in the same distance to the .
%
% The size of the sensor array is described by its edge length a
%
% $$A = a^2$$
%
% and the distance d of each coordinate to the next point in x and y
% direction
%
% $$d = \frac{a}{N-1}$$
%
% The coordinates of the array are scale from center of the square.
% So for the upper left corner position is described by
%
% $$x_{1,1} = -\frac{a}{2} \quad y_{1,1} = -\frac{a}{2} \quad z = const.$$
%
% The coodinates of each dimension are placed in matrices of size N x N
% related to the number of sensors at one edge of the square Array.
% So position pattern in x dimension are returned as
%
% $$X_0 = \left[ \matrix{x_{1,1} & \cdots & x_{1,N} \cr
%                      \vdots  & \ddots & \vdots  \cr
%                      x_{N,1} & \cdots & x_{N,N}} \right]$$
%
% $$x_{i,j} = x_{1,1} + j \cdot d - d$$
%
% same wise for y dimension but transposed
%
% $$Y_0 = \left[ \matrix{y_{1,1} & \cdots & y_{1,N} \cr
%                      \vdots  & \ddots & \vdots  \cr
%                      y_{N,1} & \cdots & y_{N,N}} \right]$$
%
% $$y_{i,j} = y_{1,1} + i \cdot d - d$$
%
% $$Y_0 = X_0^T$$
%
% and z dimension
%
% $$Z_0 = \left[ \matrix{z_{1,1} & \cdots & z_{1,N} \cr
%                      \vdots  & \ddots & \vdots  \cr
%                      z_{N,1} & \cdots & z_{N,N}} \right]$$
%
% $$z_{i,j} = 0$$
%
% for
%
% $$i = 1, 2, \ldots, N \quad j = 1, 2, \ldots, N$$
%
% A relative position shift can be performed by pass a postion vector p
% with relativ position to center
%
% $$\vec{p} = \left[ \matrix{ x_p \cr y_p \cr z_p} \right]$$
%
% So that a left shift in x and a up shift in y direction is performed by
% egativ values in p. To gain distance in z from center point so that
% center is above the sensor array increase the z positive. In addition to
% the z shift an offset r sphere can be set. The offset represents the
% radius of a sphere magnet in which center the dipole is placed.
% The dipole is placed in the center of the coordinate system and sensor
% array position is relative to the dipole or center. So shifts are
% described by
%
% $$X = X_0 + x_p \quad Y = Y_0 + y_p \quad Z = Z_0 -(z_p + r_{sp})$$
%
%
%% Syntax
%   [X, Y, Z] = generateSensorArrayGrid(N, a, p, r)
%
%
%% Description
% *[X, Y, Z] = generateSensorArrayGrid(N, a, p, r)* returns a sensor array
% grid of size N x N with grid position matrices for x, y and z positions
% of each sensor in the array.
%
%
%% Examples
%   % generate a grid of 8 x 8 sensors with no shift in x or y direction
%   and a static position of 4mm under the center in z dimension with a
%   z offset of 2mm so (2 + 2)mm
%   N = 8;
%   p = [0, 0, 2]
%   r = 2;
%   [X, Y, Z] = generateSensorArrayGrid(N, a, p, r);
%
%   % same layer but left shift by 2mm and down shift in y by 1mm
%   p = [-2, 1, 2]
%   r = 2;
%   [X, Y, Z] = generateSensorArrayGrid(N, a, p, r);
% 
%
%% Input Argurments
% *N* positive integer scalar number of sensors at one edge of the square
% grid. So the resulting grid has dimensions N x N.
%
% *a* positive real scalar value of sensor array edge length.
%
% *p* relative position vector, relative sensor array postion to center of
% the array. Place the array in 3D coorodinate system relative to the
% center of system.
%
% *r* positive real scalar is offset in z dimension and represents the
% sphere radius in which center the magnetic dipole is placed.
%
%
%% Output Argurments
% *X* x coordinates for each sensor in N x N matrix where each point has
% the same orientation as in y and z dimension.
%
% *Y* y coordinates for each sensor in N x N matrix where each point has
% the same orientation as in x and z dimension.
%
% *Z* z coordinates for each sensor in N x N matrix where each point has
% the same orientation as in x and y dimension.
%
%
%% Requirements
% * Other m-files required: None
% * Subfunctions: meshgrid
% * MAT-files required: None
%
%
%% See Also
% * <matlab:web(fullfile(docroot,'matlab/ref/meshgrid.html')) meshgrid>
% 
%
% Created on November 10. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on Month DD. YYYY by Editor: Single line description.
% REPLACE_WITH_DASH_DASH>
% </html>
%
function [X, Y, Z] = generateSensorArraySquareGrid(N, a, p, r)
    arguments
        % validate N as positive integer
        N (1,1) double {mustBePositive, mustBeInteger}
        % validate array edge length as positive scalar
        a (1,1) double {mustBeReal, mustBePositive}
        % validate p as column vector of real scalars
        p (3,1) double {mustBeReal, mustBeVector}
        % validate r as real scalar
        r (1,1) double {mustBeReal}
    end

    % half edge length for square corners
    aHalf = a / 2;
    
    % distance in x and y direction of each coordinate to next point
    d = a / (N -1);
    
    % grid vector for x and y coordinates
    g = -aHalf:d:aHalf;

    % scale grid in x and y dimension and attach the array position related
    % to the center of the coordinate system
    [X, Y] = meshgrid(g + p(1), g + p(2));
    
    % scale a z dimension with constant distances in all array positions in
    % the coordinate system and attach the z position and offset to it
    Z = zeros(N, N) - (p(3) + r);
end


##### SOURCE END #####
--></body></html>