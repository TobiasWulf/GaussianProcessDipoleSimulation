
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: {extensions: ["mhchem.js"]},
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: true
            },
            CommonHTML: {minScaleAdjust: 110,},
            "HTML-CSS": {
                availableFonts: ["TeX"],
                scale: 110
            }
        });
        MathJax.Hub.Queue(["Rerender", MathJax.Hub], function () {window.status="finished"});
    </script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>generateSensorSquareArrayGrid</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-05-01"><meta name="DC.source" content="generateSensorArraySquareGrid.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>generateSensorSquareArrayGrid</h1><!--introduction--><p>Generates a position grid of sensors in x, y and z dimension. So the function returns a grid in shape of a square in which all sensors have even distances to each and another in x and y direction z is constant due to that all sensor are in the same distance to the magnet.</p><p>The size of the sensor array is described by its edge length a</p><p><span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq15646403293203809680.png" alt="$$A = a^2$$"></span><script type="math/tex">A = a^2</script></p><p>and the distance d of each coordinate to the next point in x and y direction</p><p><span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq18234882407082815552.png" alt="$$d = \frac{a}{N-1}$$"></span><script type="math/tex">d = \frac{a}{N-1}</script></p><p>The coordinates of the array are scale from center of the square. So for the upper left corner position is described by</p><p><span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq00366142566675503231.png" alt="$$x_{1,1} = -\frac{a}{2} \quad y_{1,1} = \frac{a}{2} \quad z = const.$$"></span><script type="math/tex">x_{1,1} = -\frac{a}{2} \quad y_{1,1} = \frac{a}{2} \quad z = const.</script></p><p>The coodinates of each dimension are placed in matrices of size N x N related to the number of sensors at one edge of the square Array. So position pattern in x dimension are returned as <span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq14217025108342228743.png" alt="$X_0$"></span><script type="math/tex">X_0</script> with</p><p><span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq14796959324621073533.png" alt="$$x_{i,j} = x_{1,1} + j \cdot d - d$$"></span><script type="math/tex">x_{i,j} = x_{1,1} + j \cdot d - d</script></p><p>same wise for y dimension but transposed <span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq10166276556963389151.png" alt="$X_0 = Y_0^T$"></span><script type="math/tex">X_0 = Y_0^T</script> with</p><p><span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq15376869178921526307.png" alt="$$y_{i,j} = y_{1,1} - i \cdot d + d$$"></span><script type="math/tex">y_{i,j} = y_{1,1} - i \cdot d + d</script></p><p>and z dimension <span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq15625750297609208514.png" alt="$Z_0 = const.$"></span><script type="math/tex">Z_0 = const.</script> with <span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq12744129975354353653.png" alt="$z_{i,j} = 0$"></span><script type="math/tex">z_{i,j} = 0</script></p><p>for</p><p><span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq17629341197877401447.png" alt="$$i = 1, 2, \ldots, N \quad j = 1, 2, \ldots, N$$"></span><script type="math/tex">i = 1, 2, \ldots, N \quad j = 1, 2, \ldots, N</script></p><p>A relative position shift can be performed by pass a position vector p with relativ position to center</p><p><span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq18264619652804356402.png" alt="$$\vec{p} = (x_p,y_p,z_p)^T$$"></span><script type="math/tex">\vec{p} = (x_p,y_p,z_p)^T</script></p><p>So that a left shift in x direction relative to the magnet in the center of the coordinate system is done by negative values for p(1) and an up shift in y direction is performed by positive values for p(2). To gain distance in z from center point so the magnet is above the z layer of the sensor array increase the z positive. In addition to the z shift an offset r sphere can be set. The offset represents the radius of a sphere magnet in which center the dipole is placed. The dipole is placed in the center of the coordinate system and sensor array position is relative to the dipole or center. So shifts are described by</p><p><span class="MathJax_Preview"><img src="generateSensorArraySquareGrid_eq00049857175735723296.png" alt="$$X = X_0 + x_p \quad Y = Y_0 + y_p \quad Z = Z_0 -(z_p + r_{sp})$$"></span><script type="math/tex">X = X_0 + x_p \quad Y = Y_0 + y_p \quad Z = Z_0 -(z_p + r_{sp})</script></p><!--/introduction--><h2 id="1">Syntax</h2><pre class="language-matlab">[X, Y, Z] = generateSensorArrayGrid(N, a, p, r)
</pre><h2 id="2">Description</h2><p><b>[X, Y, Z] = generateSensorArrayGrid(N, a, p, r)</b> returns a sensor array grid of size N x N with grid position matrices for x, y and z positions of each sensor in the array.</p><h2 id="3">Examples</h2><pre class="language-matlab"><span class="comment">% generate a grid of 8 x 8 sensors with no shift in x or y direction</span>
and <span class="string">a</span> <span class="string">static</span> <span class="string">position</span> <span class="string">of</span> <span class="string">4mm</span> <span class="string">under</span> <span class="string">the</span> <span class="string">center</span> <span class="string">in</span> <span class="string">z</span> <span class="string">dimension</span> <span class="string">with</span> <span class="string">a</span>
z <span class="string">offset</span> <span class="string">of</span> <span class="string">2mm</span> <span class="string">so</span> <span class="string">(2 + 2)mm</span>
N = 8;
p = [0, 0, 2]
r = 2;
[X, Y, Z] = generateSensorArrayGrid(N, a, p, r);
</pre><pre class="language-matlab"><span class="comment">% same layer but left shift by 2mm and down shift in y by 1mm</span>
p = [-2, 1, 2]
r = 2;
[X, Y, Z] = generateSensorArrayGrid(N, a, p, r);
</pre><h2 id="4">Input Argurments</h2><p><b>N</b> positive integer scalar number of sensors at one edge of the square grid. So the resulting grid has dimensions N x N.</p><p><b>a</b> positive real scalar value of sensor array edge length.</p><p><b>p</b> relative position vector, relative sensor array postion to center of the array. Place the array in 3D coorodinate system relative to the center of system.</p><p><b>r</b> positive real scalar is offset in z dimension and represents the sphere radius in which center the magnetic dipole is placed.</p><h2 id="5">Output Argurments</h2><p><b>X</b> x coordinates for each sensor in N x N matrix where each point has the same orientation as in y and z dimension.</p><p><b>Y</b> y coordinates for each sensor in N x N matrix where each point has the same orientation as in x and z dimension.</p><p><b>Z</b> z coordinates for each sensor in N x N matrix where each point has the same orientation as in x and y dimension.</p><h2 id="6">Requirements</h2><div><ul><li>Other m-files required: None</li><li>Subfunctions: meshgrid</li><li>MAT-files required: None</li></ul></div><h2 id="7">See Also</h2><div><ul><li><a href="matlab:web(fullfile(docroot,'matlab/ref/meshgrid.html'))">meshgrid</a></li></ul></div><p>Created on November 10. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.</p><p>
<!--
Hidden Clutter.
Edited on Month DD. YYYY by Editor: Single line description.
-->
</p><pre class="codeinput"><span class="keyword">function</span> [X, Y, Z] = generateSensorArraySquareGrid(N, a, p, r)
    <span class="keyword">arguments</span>
        <span class="comment">% validate N as positive integer</span>
        N <span class="typesection">(1,1) double {mustBePositive, mustBeInteger}</span>
        <span class="comment">% validate array edge length as positive scalar</span>
        a <span class="typesection">(1,1) double {mustBeReal, mustBePositive}</span>
        <span class="comment">% validate p as column vector of real scalars</span>
        p <span class="typesection">(3,1) double {mustBeReal, mustBeVector}</span>
        <span class="comment">% validate r as real scalar</span>
        r <span class="typesection">(1,1) double {mustBeReal}</span>
    <span class="keyword">end</span>

    <span class="comment">% half edge length for square corners</span>
    aHalf = a / 2;

    <span class="comment">% distance in x and y direction of each coordinate to next point</span>
    d = a / (N - 1);

    <span class="comment">% grid vector for x and y coordinates z is constant layer with shifts</span>
    x = (-aHalf:d:aHalf) + p(1);
    y = (aHalf:-d:-aHalf) + p(2);
    z = -(p(3) + r);

    <span class="comment">% scale grid in x, y dimension with constant z dimension</span>
    [X, Y, Z] = meshgrid(x, y, z);
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% generateSensorSquareArrayGrid
% Generates a position grid of sensors in x, y and z dimension. So the
% function returns a grid in shape of a square in which all sensors have 
% even distances to each and another in x and y direction z is constant due
% to that all sensor are in the same distance to the magnet.
%
% The size of the sensor array is described by its edge length a
%
% $$A = a^2$$
%
% and the distance d of each coordinate to the next point in x and y
% direction
%
% $$d = \frac{a}{N-1}$$
%
% The coordinates of the array are scale from center of the square.
% So for the upper left corner position is described by
%
% $$x_{1,1} = -\frac{a}{2} \quad y_{1,1} = \frac{a}{2} \quad z = const.$$
%
% The coodinates of each dimension are placed in matrices of size N x N
% related to the number of sensors at one edge of the square Array.
% So position pattern in x dimension are returned as $X_0$ with
%
% $$x_{i,j} = x_{1,1} + j \cdot d - d$$
%
% same wise for y dimension but transposed $X_0 = Y_0^T$ with
%
% $$y_{i,j} = y_{1,1} - i \cdot d + d$$
%
% and z dimension $Z_0 = const.$ with $z_{i,j} = 0$
%
% for
%
% $$i = 1, 2, \ldots, N \quad j = 1, 2, \ldots, N$$
%
% A relative position shift can be performed by pass a position vector p
% with relativ position to center
%
% $$\vec{p} = (x_p,y_p,z_p)^T$$
%
% So that a left shift in x direction relative to the magnet in the center
% of the coordinate system is done by negative values for p(1) and an up 
% shift in y direction is performed by positive values for p(2). To gain
% distance in z from center point so the magnet is above the z layer of the
% sensor array increase the z positive. In addition to the z shift an 
% offset r sphere can be set. The offset represents the radius of a sphere
% magnet in which center the dipole is placed. The dipole is placed in the
% center of the coordinate system and sensor array position is relative to
% the dipole or center. So shifts are described by
%
% $$X = X_0 + x_p \quad Y = Y_0 + y_p \quad Z = Z_0 -(z_p + r_{sp})$$
%
%
%% Syntax
%   [X, Y, Z] = generateSensorArrayGrid(N, a, p, r)
%
%
%% Description
% *[X, Y, Z] = generateSensorArrayGrid(N, a, p, r)* returns a sensor array
% grid of size N x N with grid position matrices for x, y and z positions
% of each sensor in the array.
%
%
%% Examples
%   % generate a grid of 8 x 8 sensors with no shift in x or y direction
%   and a static position of 4mm under the center in z dimension with a
%   z offset of 2mm so (2 + 2)mm
%   N = 8;
%   p = [0, 0, 2]
%   r = 2;
%   [X, Y, Z] = generateSensorArrayGrid(N, a, p, r);
%
%   % same layer but left shift by 2mm and down shift in y by 1mm
%   p = [-2, 1, 2]
%   r = 2;
%   [X, Y, Z] = generateSensorArrayGrid(N, a, p, r);
% 
%
%% Input Argurments
% *N* positive integer scalar number of sensors at one edge of the square
% grid. So the resulting grid has dimensions N x N.
%
% *a* positive real scalar value of sensor array edge length.
%
% *p* relative position vector, relative sensor array postion to center of
% the array. Place the array in 3D coorodinate system relative to the
% center of system.
%
% *r* positive real scalar is offset in z dimension and represents the
% sphere radius in which center the magnetic dipole is placed.
%
%
%% Output Argurments
% *X* x coordinates for each sensor in N x N matrix where each point has
% the same orientation as in y and z dimension.
%
% *Y* y coordinates for each sensor in N x N matrix where each point has
% the same orientation as in x and z dimension.
%
% *Z* z coordinates for each sensor in N x N matrix where each point has
% the same orientation as in x and y dimension.
%
%
%% Requirements
% * Other m-files required: None
% * Subfunctions: meshgrid
% * MAT-files required: None
%
%
%% See Also
% * <matlab:web(fullfile(docroot,'matlab/ref/meshgrid.html')) meshgrid>
% 
%
% Created on November 10. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on Month DD. YYYY by Editor: Single line description.
% REPLACE_WITH_DASH_DASH>
% </html>
%
function [X, Y, Z] = generateSensorArraySquareGrid(N, a, p, r)
    arguments
        % validate N as positive integer
        N (1,1) double {mustBePositive, mustBeInteger}
        % validate array edge length as positive scalar
        a (1,1) double {mustBeReal, mustBePositive}
        % validate p as column vector of real scalars
        p (3,1) double {mustBeReal, mustBeVector}
        % validate r as real scalar
        r (1,1) double {mustBeReal}
    end

    % half edge length for square corners
    aHalf = a / 2;
    
    % distance in x and y direction of each coordinate to next point
    d = a / (N - 1);
    
    % grid vector for x and y coordinates z is constant layer with shifts
    x = (-aHalf:d:aHalf) + p(1);
    y = (aHalf:-d:-aHalf) + p(2);
    z = -(p(3) + r);

    % scale grid in x, y dimension with constant z dimension
    [X, Y, Z] = meshgrid(x, y, z);
end


##### SOURCE END #####
--></body></html>