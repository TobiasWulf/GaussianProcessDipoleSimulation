
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>generateConfigMat</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-11-22"><meta name="DC.source" content="generateConfigMat.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>generateConfigMat</h1><!--introduction--><p>Generate configuration mat-file wich contains reusable configuration to control the software or certain function parameters. Centralized collection of configuration. If it is certain configuration needed place it here.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Requirements</a></li><li><a href="#2">See Also</a></li><li><a href="#3">Clean Up</a></li><li><a href="#4">GeneralOptions</a></li><li><a href="#5">Path Variables</a></li><li><a href="#6">Publish Options</a></li><li><a href="#7">Sensor Array Options</a></li><li><a href="#8">Dipole Options</a></li><li><a href="#9">Traning Options</a></li><li><a href="#10">Test Options</a></li><li><a href="#11">Save Configuration</a></li></ul></div><h2 id="1">Requirements</h2><div><ul><li>Other m-files required: None</li><li>Subfunctions: None</li><li>MAT-files required: None</li></ul></div><h2 id="2">See Also</h2><div><ul><li><a href="matlab:web(fullfile(docroot,'matlab/ref/save.html'))">save</a></li><li><a href="matlab:web(fullfile(docroot,'matlab/ref/load.html'))">load</a></li><li><a href="matlab:web(fullfile(docroot,'matlab/ref/matlab.io.matfile.html'))">matfile</a></li></ul></div><p>Created on October 29. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.</p><p>
<!--
Hidden Clutter.
Edited on Month DD. YYYY by Editor: Single line description.
Edited on November 09. 2020 by Tobias Wulf: Save PathVariables as struct.
Edited on November 09. 2020 by Tobias Wulf: Add Options for dipole simulation with square sensor array.
-->
</p><h2 id="3">Clean Up</h2><p>Clear variables from workspace to build up a fresh new configuration workspace.</p><pre class="codeinput">disp(<span class="string">'Clean up workspace ...'</span>);
clearvars;
clc;
</pre><h2 id="4">GeneralOptions</h2><p>General options like formats for strings or date or anything else what has no special relation to a theme complex.</p><pre class="codeinput">disp(<span class="string">'Set general options ...'</span>);
GeneralOptions = struct;
GeneralOptions.dateFormat = <span class="string">'yyyy-mm-dd_HH-MM-SS-FFF'</span>;
</pre><h2 id="5">Path Variables</h2><p>Key path variables and directories, often used in functions or scripts. Collet the path in a struct for easier save the struct fields as variables to config.mat via -struct flag.</p><pre class="codeinput">disp(<span class="string">'Create current project instance to gather information ...'</span>);

<span class="comment">% create current project instance to retrieve root information</span>
projectInstance = matlab.project.currentProject;

disp(<span class="string">'Set path variables ...'</span>);
PathVariables =struct;

<span class="comment">% project root path, needs to be recreated generic to work on different machines</span>
PathVariables.rootPath = projectInstance.RootFolder;

<span class="comment">% path to data folder, which contains datasets and config.mat</span>
PathVariables.dataPath = fullfile(PathVariables.rootPath, <span class="string">'data'</span>);

<span class="comment">% path to TDK TAS2141 TMR angular sensor characterization dataset</span>
PathVariables.tdkDatasetPath = fullfile(PathVariables.dataPath, <span class="keyword">...</span>
    <span class="string">'TDK_TAS2141_Characterization_2020-10-22_18-12-16-827.mat'</span>);

<span class="comment">% path to config file dataset</span>
PathVariables.configPath = fullfile(PathVariables.dataPath, <span class="string">'config.mat'</span>);

<span class="comment">% path to documentation and m-files only for documentation</span>
PathVariables.docsPath = fullfile(PathVariables.rootPath, <span class="string">'docs'</span>);

<span class="comment">% path to publish html documentation output directory, helptoc.xml location</span>
PathVariables.publishHtmlPath = fullfile(PathVariables.docsPath, <span class="string">'html'</span>);

<span class="comment">% path to save plots as images svg, eps, png, etc.</span>
PathVariables.saveImagesPath = fullfile(PathVariables.publishHtmlPath, <span class="string">'images'</span>);

<span class="comment">% path to save matlab figures</span>
PathVariables.saveFiguresPath = fullfile(PathVariables.publishHtmlPath, <span class="string">'figures'</span>);

<span class="comment">% path to style sheet for html documentation, Matlab provided style sheet</span>
PathVariables.publishStyleSheetPath = string(fullfile(matlabroot, <span class="string">'toolbox'</span>, <span class="keyword">...</span>
    <span class="string">'matlab'</span>, <span class="string">'codetools'</span>, <span class="string">'private'</span>, <span class="string">'mxdom2simplehtml.xsl'</span>));

<span class="comment">% path to documentation search database entries for Matlab help browser support</span>
PathVariables.helpsearchPath = fullfile(PathVariables.publishHtmlPath, <span class="keyword">...</span>
    <span class="string">'helpsearch-v3'</span>);

<span class="comment">% path to executable m-file scripts of the project</span>
PathVariables.scriptsPath = fullfile(PathVariables.rootPath, <span class="string">'scripts'</span>);

<span class="comment">% path to source code files, function and class files</span>
PathVariables.srcPath = fullfile(PathVariables.rootPath, <span class="string">'src'</span>);
</pre><h2 id="6">Publish Options</h2><p>These are general options for documents to publish. They are passed to the matlab publish function via a struct where each option gets its own field. The option struct can be copied and adjusted for differing publish conditions in example for scripts, functions, and bare document m-files. Initialize the option struct with output format field name and field value and add further fields (options) with point value.</p><pre class="codeinput">disp(<span class="string">'Set publish options struct for publish function ...'</span>);
PublishOptions = struct(<span class="string">'format'</span>, <span class="string">'html'</span>);
PublishOptions.outputDir = PathVariables.publishHtmlPath;
PublishOptions.stylesheet = PathVariables.publishStyleSheetPath;
PublishOptions.createThumbnail = false;
PublishOptions.figureSnapMethod = <span class="string">'entireFigureWindow'</span>;
PublishOptions.imageFormat = <span class="string">'png'</span>;
PublishOptions.maxHeight = [];
PublishOptions.maxWidth = [];
PublishOptions.useNewFigure = false;
PublishOptions.evalCode = false;
PublishOptions.catchError = true;
PublishOptions.codeToEvaluate = [];
PublishOptions.maxOutputLines = Inf;
PublishOptions.showCode = true;
</pre><h2 id="7">Sensor Array Options</h2><p>The options control the build up of the sensor array in geometry and techincal behavior. This means number of sensors in the array and its size in mm. The supply and offset voltage of each sensor which is needed for using the characterization which is normed in mV/V.</p><pre class="codeinput">disp(<span class="string">'Set sensor array option for geometry and behavior ...'</span>);
SensorArrayOptions = struct;

<span class="comment">% Geometry of the sensor array current sensor array can be</span>
<span class="comment">% square - square sensor array with even distances to each sensor point</span>
SensorArrayOptions.geometry = <span class="string">'square'</span>;

<span class="comment">% Sensor array square dimension</span>
SensorArrayOptions.dimension = 8;

<span class="comment">% Sensor array edge length in mm</span>
SensorArrayOptions.edge = 2;

<span class="comment">% Sensor array simulated supply voltage in volts</span>
SensorArrayOptions.Vcc = 3.3;

<span class="comment">% Sensor array simulated offset voltage for bridge outputs in volts</span>
SensorArrayOptions.Voff = 1.65;

<span class="comment">% Senor array voltage norm factor to recalculate norm bridge outputs to</span>
<span class="comment">% given supply voltage and offset voltage, current normin is mV/V which</span>
<span class="comment">% implements factor of 1e3</span>
SensorArrayOptions.Vnorm = 1e3;
</pre><h2 id="8">Dipole Options</h2><p>Dipole options to calculate the magnetic field which stimulate the sensor array. The dipole is gained to sphere with additional z distance to the array by sphere radius.</p><pre class="codeinput">disp(<span class="string">'Set dipole options to calculate magnetic stimulus ...'</span>);
DipoleOptions = struct;

<span class="comment">% Radius in mm of magnetic sphere in which the magnetic dipole is centered.</span>
<span class="comment">% So it can be seen as z-offset to the sensor array.</span>
DipoleOptions.sphereRadius = 2;

<span class="comment">% H-field magnitude to multiply of generated and relative normed dipole</span>
<span class="comment">% H-fields, the norming is done in zero position of [0 0 z0 + sphere radius] for</span>
<span class="comment">% 0&deg; due to the position of the magnetic moment [-1 0 0] x and y components</span>
<span class="comment">% are not relevant, norming without tilt. Magnitude in kA/m. The magnitude</span>
<span class="comment">% refers that the sphere magnet has this H-field magnitude in a certain distance</span>
<span class="comment">% z0 in example sphere with 2mm sphere radius has a H magnitude of 200kA/m in</span>
<span class="comment">% 5mm distance. Standard field strength for ferrite sphere magnets are between</span>
<span class="comment">% 180 and 200kA/m.</span>
DipoleOptions.Hmag = 200;

<span class="comment">% Distance in zero position of the spherical magnet in which the imprinted</span>
<span class="comment">% H-field strength magnitude takes effect. Together with the sphere radius and</span>
<span class="comment">% and the imprinted field strength magnitude the distance in rest position</span>
<span class="comment">% characterizes the spherical magnet to later relative positions of the sensor</span>
<span class="comment">% array and generated dipole H-fields in rotation simulation.</span>
DipoleOptions.z0 = 1;

<span class="comment">% Magnetic moment magnitude attach rotation to the dipole field at a</span>
<span class="comment">% certain position with x, y and z components. Choose a huge value to</span>
<span class="comment">% prevent numeric failures</span>
DipoleOptions.Mmag = 1e6;
</pre><h2 id="9">Traning Options</h2><p>Training options gives the software the needed information to generate training datasets by the sensor array simulation with a dipole manget as stimulus which pushed with an z offeset to a sphere.</p><pre class="codeinput">disp(<span class="string">'Set training options to generate dataset ...'</span>);
TrainingOptions = struct;

<span class="comment">% Sensor array relative position to dipole magnet as position vector with</span>
<span class="comment">% x, y and z posiotn in mm. Negative x for left shift, negative y for up</span>
<span class="comment">% shift and negative z to place the layer under the dipole decrease z to</span>
<span class="comment">% increase the distance. The z-position will be subtracted by dipole sphere</span>
<span class="comment">% radius in simulation. So there is an offset given by the sphere radius</span>
TrainingOptions.xPos = [0,];
TrainingOptions.yPos = [0,];
TrainingOptions.zPos = [0,];

<span class="comment">% Dipole tilt in z-axes</span>
TrainingOptions.tilt = [0,];

<span class="comment">% Resolution of rotaion in degree, use same resoultion in training and test</span>
<span class="comment">% datasets to have the ability to back reference the index to fullscale</span>
<span class="comment">% test data sets</span>
TrainingOptions.angleRes = 0.5;

<span class="comment">% Phase index applies a phase offset in the rotation, it is used as phase index</span>
<span class="comment">% to a down sampling to generate even distributed angles of a full scale</span>
<span class="comment">% rotation. Offset index of full rotation. In example a full scale rotation from</span>
<span class="comment">% 0&deg; to 360&deg; - angleRes returns 720 angles, if nAngles is set to 7 it returns 7</span>
<span class="comment">% angles [0, 51.5, 103, 154.5, 206, 257.5, 309]. To get a phase shift of 11&deg; set</span>
<span class="comment">% phaseIndex to 22 a multiple of the resolution angleRes and get</span>
<span class="comment">% [11, 62.5, 114, 165.5, 217, 268.5, 320]. Must be positive integer.</span>
TrainingOptions.phaseIndex = 0;

<span class="comment">% Number rotaion angles, even distribute between 0&deg; and 360&deg; with respect</span>
<span class="comment">% to the resolution, even down sampling. To generate full scale the number</span>
<span class="comment">% relatead to the resolution or fast generate but wrong number set it to 0 to</span>
<span class="comment">% generate full scale rotation too.</span>
TrainingOptions.nAngles = [7,];
</pre><h2 id="10">Test Options</h2><p>Test options gives the software the needed information to generate test datasets by the sensor array simulation with a dipole manget as stimulus which pushed with an z offeset to a sphere.</p><pre class="codeinput">disp(<span class="string">'Set test options to generate dataset ...'</span>);
TestOptions = struct;

<span class="comment">% Sensor array relative position to dipole magnet as position vector with</span>
<span class="comment">% x, y and z posiotn in mm. Negative x for left shift, negative y for up</span>
<span class="comment">% shift and negative z to place the layer under the dipole decrease z to</span>
<span class="comment">% increase the distance. The z-position will be subtracted by dipole sphere</span>
<span class="comment">% radius in simulation. So there is an offset given by the sphere radius</span>
TestOptions.xPos = [0,];
TestOptions.yPos = [0,];
TestOptions.zPos = [0, 1, 2, 3, 4];

<span class="comment">% Dipole tilt in z-axes</span>
TestOptions.tilt = [0,];

<span class="comment">% Resolution of rotaion in degree, use same resoultion in training and test</span>
<span class="comment">% datasets to have the ability to back reference the index to fullscale</span>
<span class="comment">% test data sets</span>
TestOptions.angleRes = 0.5;

<span class="comment">% Phase index applies a phase offset in the rotation, it is used as phase index</span>
<span class="comment">% to a down sampling to generate even distributed angles of a full scale</span>
<span class="comment">% rotation. Offset index of full rotation. In example a full scale rotation from</span>
<span class="comment">% 0&deg; to 360&deg; - angleRes returns 720 angles, if nAngles is set to 7 it returns 7</span>
<span class="comment">% angles [0, 51.5, 103, 154.5, 206, 257.5, 309]. To get a phase shift of 11&deg; set</span>
<span class="comment">% phaseIndex to 22 a multiple of the resolution angleRes and get</span>
<span class="comment">% [11, 62.5, 114, 165.5, 217, 268.5, 320]. Must be positive integer.</span>
TestOptions.phaseIndex = 0;

<span class="comment">% Number rotaion angles, even distribute between 0&deg; and 360&deg; with respect</span>
<span class="comment">% to the resolution, even down sampling. To generate full scale the number</span>
<span class="comment">% relatead to the resolution or fast generate but wrong number to 0 to</span>
<span class="comment">% generate full scale rotation.</span>
TestOptions.nAngles = [720,];
</pre><h2 id="11">Save Configuration</h2><p>Save section wise each config part as struct to standalone variables in config.mat use newest save format with no compression.</p><pre class="codeinput"><span class="comment">% create config.mat with timestamp of creation</span>
disp(<span class="string">'Create config.mat ...'</span>);
timestamp = datestr(now, GeneralOptions.dateFormat);
save(PathVariables.configPath, <span class="keyword">...</span>
    <span class="string">'timestamp'</span>, <span class="keyword">...</span>
    <span class="string">'PathVariables'</span>, <span class="keyword">...</span>
    <span class="string">'PublishOptions'</span>, <span class="keyword">...</span>
    <span class="string">'SensorArrayOptions'</span>, <span class="keyword">...</span>
    <span class="string">'DipoleOptions'</span>, <span class="keyword">...</span>
    <span class="string">'TrainingOptions'</span>, <span class="keyword">...</span>
    <span class="string">'TestOptions'</span>, <span class="keyword">...</span>
    <span class="string">'-v7.3'</span>, <span class="string">'-nocompression'</span>);
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% generateConfigMat
% Generate configuration mat-file wich contains reusable configuration to
% control the software or certain function parameters. Centralized collection of
% configuration. If it is certain configuration needed place it here.
%
%
%% Requirements
% * Other m-files required: None
% * Subfunctions: None
% * MAT-files required: None
%
%
%% See Also
% * <matlab:web(fullfile(docroot,'matlab/ref/save.html')) save>
% * <matlab:web(fullfile(docroot,'matlab/ref/load.html')) load>
% * <matlab:web(fullfile(docroot,'matlab/ref/matlab.io.matfile.html')) matfile>
%
%
% Created on October 29. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on Month DD. YYYY by Editor: Single line description.
% Edited on November 09. 2020 by Tobias Wulf: Save PathVariables as struct.
% Edited on November 09. 2020 by Tobias Wulf: Add Options for dipole simulation with square sensor array.
% REPLACE_WITH_DASH_DASH>
% </html>
%
%
%% Clean Up
% Clear variables from workspace to build up a fresh new configuration
% workspace.
disp('Clean up workspace ...');
clearvars;
clc;


%% GeneralOptions
% General options like formats for strings or date or anything else what
% has no special relation to a theme complex.
disp('Set general options ...');
GeneralOptions = struct;
GeneralOptions.dateFormat = 'yyyy-mm-dd_HH-MM-SS-FFF';


%% Path Variables
% Key path variables and directories, often used in functions or scripts.
% Collet the path in a struct for easier save the struct fields as variables to
% config.mat via -struct flag.

disp('Create current project instance to gather information ...');

% create current project instance to retrieve root information
projectInstance = matlab.project.currentProject;

disp('Set path variables ...');
PathVariables =struct;

% project root path, needs to be recreated generic to work on different machines
PathVariables.rootPath = projectInstance.RootFolder;

% path to data folder, which contains datasets and config.mat
PathVariables.dataPath = fullfile(PathVariables.rootPath, 'data');

% path to TDK TAS2141 TMR angular sensor characterization dataset
PathVariables.tdkDatasetPath = fullfile(PathVariables.dataPath, ... 
    'TDK_TAS2141_Characterization_2020-10-22_18-12-16-827.mat');

% path to config file dataset
PathVariables.configPath = fullfile(PathVariables.dataPath, 'config.mat');

% path to documentation and m-files only for documentation
PathVariables.docsPath = fullfile(PathVariables.rootPath, 'docs');

% path to publish html documentation output directory, helptoc.xml location
PathVariables.publishHtmlPath = fullfile(PathVariables.docsPath, 'html');

% path to save plots as images svg, eps, png, etc.
PathVariables.saveImagesPath = fullfile(PathVariables.publishHtmlPath, 'images');

% path to save matlab figures
PathVariables.saveFiguresPath = fullfile(PathVariables.publishHtmlPath, 'figures');

% path to style sheet for html documentation, Matlab provided style sheet
PathVariables.publishStyleSheetPath = string(fullfile(matlabroot, 'toolbox', ...
    'matlab', 'codetools', 'private', 'mxdom2simplehtml.xsl'));

% path to documentation search database entries for Matlab help browser support
PathVariables.helpsearchPath = fullfile(PathVariables.publishHtmlPath, ...
    'helpsearch-v3');

% path to executable m-file scripts of the project
PathVariables.scriptsPath = fullfile(PathVariables.rootPath, 'scripts');

% path to source code files, function and class files
PathVariables.srcPath = fullfile(PathVariables.rootPath, 'src');


%% Publish Options
% These are general options for documents to publish. They are passed to the
% matlab publish function via a struct where each option gets its own field.
% The option struct can be copied and adjusted for differing publish
% conditions in example for scripts, functions, and bare document m-files.
% Initialize the option struct with output format field name and field value
% and add further fields (options) with point value.
disp('Set publish options struct for publish function ...');
PublishOptions = struct('format', 'html');
PublishOptions.outputDir = PathVariables.publishHtmlPath;
PublishOptions.stylesheet = PathVariables.publishStyleSheetPath;
PublishOptions.createThumbnail = false;
PublishOptions.figureSnapMethod = 'entireFigureWindow';
PublishOptions.imageFormat = 'png';
PublishOptions.maxHeight = [];
PublishOptions.maxWidth = [];
PublishOptions.useNewFigure = false;
PublishOptions.evalCode = false;
PublishOptions.catchError = true;
PublishOptions.codeToEvaluate = [];
PublishOptions.maxOutputLines = Inf;
PublishOptions.showCode = true;


%% Sensor Array Options
% The options control the build up of the sensor array in geometry and
% techincal behavior. This means number of sensors in the array and its
% size in mm. The supply and offset voltage of each sensor which is needed
% for using the characterization which is normed in mV/V.
disp('Set sensor array option for geometry and behavior ...');
SensorArrayOptions = struct;

% Geometry of the sensor array current sensor array can be
% square - square sensor array with even distances to each sensor point
SensorArrayOptions.geometry = 'square';

% Sensor array square dimension
SensorArrayOptions.dimension = 8;

% Sensor array edge length in mm
SensorArrayOptions.edge = 2;

% Sensor array simulated supply voltage in volts
SensorArrayOptions.Vcc = 3.3;

% Sensor array simulated offset voltage for bridge outputs in volts
SensorArrayOptions.Voff = 1.65;

% Senor array voltage norm factor to recalculate norm bridge outputs to
% given supply voltage and offset voltage, current normin is mV/V which
% implements factor of 1e3
SensorArrayOptions.Vnorm = 1e3;


%% Dipole Options
% Dipole options to calculate the magnetic field which stimulate the sensor
% array. The dipole is gained to sphere with additional z distance to the
% array by sphere radius.
disp('Set dipole options to calculate magnetic stimulus ...');
DipoleOptions = struct;

% Radius in mm of magnetic sphere in which the magnetic dipole is centered.
% So it can be seen as z-offset to the sensor array.
DipoleOptions.sphereRadius = 2;

% H-field magnitude to multiply of generated and relative normed dipole
% H-fields, the norming is done in zero position of [0 0 z0 + sphere radius] for
% 0° due to the position of the magnetic moment [-1 0 0] x and y components
% are not relevant, norming without tilt. Magnitude in kA/m. The magnitude
% refers that the sphere magnet has this H-field magnitude in a certain distance
% z0 in example sphere with 2mm sphere radius has a H magnitude of 200kA/m in
% 5mm distance. Standard field strength for ferrite sphere magnets are between
% 180 and 200kA/m.
DipoleOptions.Hmag = 200;

% Distance in zero position of the spherical magnet in which the imprinted
% H-field strength magnitude takes effect. Together with the sphere radius and
% and the imprinted field strength magnitude the distance in rest position
% characterizes the spherical magnet to later relative positions of the sensor
% array and generated dipole H-fields in rotation simulation.
DipoleOptions.z0 = 1;

% Magnetic moment magnitude attach rotation to the dipole field at a
% certain position with x, y and z components. Choose a huge value to
% prevent numeric failures
DipoleOptions.Mmag = 1e6;


%% Traning Options
% Training options gives the software the needed information to generate
% training datasets by the sensor array simulation with a dipole manget as
% stimulus which pushed with an z offeset to a sphere.
disp('Set training options to generate dataset ...');
TrainingOptions = struct;

% Sensor array relative position to dipole magnet as position vector with
% x, y and z posiotn in mm. Negative x for left shift, negative y for up
% shift and negative z to place the layer under the dipole decrease z to
% increase the distance. The z-position will be subtracted by dipole sphere
% radius in simulation. So there is an offset given by the sphere radius
TrainingOptions.xPos = [0,];
TrainingOptions.yPos = [0,];
TrainingOptions.zPos = [0,];

% Dipole tilt in z-axes
TrainingOptions.tilt = [0,];

% Resolution of rotaion in degree, use same resoultion in training and test
% datasets to have the ability to back reference the index to fullscale
% test data sets 
TrainingOptions.angleRes = 0.5;

% Phase index applies a phase offset in the rotation, it is used as phase index
% to a down sampling to generate even distributed angles of a full scale
% rotation. Offset index of full rotation. In example a full scale rotation from
% 0° to 360° - angleRes returns 720 angles, if nAngles is set to 7 it returns 7
% angles [0, 51.5, 103, 154.5, 206, 257.5, 309]. To get a phase shift of 11° set
% phaseIndex to 22 a multiple of the resolution angleRes and get
% [11, 62.5, 114, 165.5, 217, 268.5, 320]. Must be positive integer.
TrainingOptions.phaseIndex = 0;

% Number rotaion angles, even distribute between 0° and 360° with respect
% to the resolution, even down sampling. To generate full scale the number
% relatead to the resolution or fast generate but wrong number set it to 0 to
% generate full scale rotation too.
TrainingOptions.nAngles = [7,];


%% Test Options
% Test options gives the software the needed information to generate
% test datasets by the sensor array simulation with a dipole manget as
% stimulus which pushed with an z offeset to a sphere.
disp('Set test options to generate dataset ...');
TestOptions = struct;

% Sensor array relative position to dipole magnet as position vector with
% x, y and z posiotn in mm. Negative x for left shift, negative y for up
% shift and negative z to place the layer under the dipole decrease z to
% increase the distance. The z-position will be subtracted by dipole sphere
% radius in simulation. So there is an offset given by the sphere radius
TestOptions.xPos = [0,];
TestOptions.yPos = [0,];
TestOptions.zPos = [0, 1, 2, 3, 4];

% Dipole tilt in z-axes
TestOptions.tilt = [0,];

% Resolution of rotaion in degree, use same resoultion in training and test
% datasets to have the ability to back reference the index to fullscale
% test data sets 
TestOptions.angleRes = 0.5;

% Phase index applies a phase offset in the rotation, it is used as phase index
% to a down sampling to generate even distributed angles of a full scale
% rotation. Offset index of full rotation. In example a full scale rotation from
% 0° to 360° - angleRes returns 720 angles, if nAngles is set to 7 it returns 7
% angles [0, 51.5, 103, 154.5, 206, 257.5, 309]. To get a phase shift of 11° set
% phaseIndex to 22 a multiple of the resolution angleRes and get
% [11, 62.5, 114, 165.5, 217, 268.5, 320]. Must be positive integer.
TestOptions.phaseIndex = 0;

% Number rotaion angles, even distribute between 0° and 360° with respect
% to the resolution, even down sampling. To generate full scale the number
% relatead to the resolution or fast generate but wrong number to 0 to
% generate full scale rotation.
TestOptions.nAngles = [720,];


%% Save Configuration
% Save section wise each config part as struct to standalone variables in
% config.mat use newest save format with no compression.

% create config.mat with timestamp of creation
disp('Create config.mat ...');
timestamp = datestr(now, GeneralOptions.dateFormat);
save(PathVariables.configPath, ...
    'timestamp', ...
    'PathVariables', ...
    'PublishOptions', ... 
    'SensorArrayOptions', ... 
    'DipoleOptions', ...
    'TrainingOptions', ... 
    'TestOptions', ...
    '-v7.3', '-nocompression');

##### SOURCE END #####
--></body></html>