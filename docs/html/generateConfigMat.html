
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: {extensions: ["mhchem.js"]},
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: true
            },
            CommonHTML: {minScaleAdjust: 110,},
            "HTML-CSS": {
                availableFonts: ["TeX"],
                scale: 110
            }
        });
        MathJax.Hub.Queue(["Rerender", MathJax.Hub], function () {window.status="finished"});
    </script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>generateConfigMat</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-05-02"><meta name="DC.source" content="generateConfigMat.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>generateConfigMat</h1><!--introduction--><p>Generate configuration mat-file wich contains reusable configuration to control the software or certain function parameters. Centralized collection of configuration. If it is certain configuration needed place it here.</p><!--/introduction--><h2 id="1">Requirements</h2><div><ul><li>Other m-files required: None</li><li>Subfunctions: None</li><li>MAT-files required: None</li></ul></div><h2 id="2">See Also</h2><div><ul><li><a href="matlab:web(fullfile(docroot,'matlab/ref/save.html'))">save</a></li><li><a href="matlab:web(fullfile(docroot,'matlab/ref/load.html'))">load</a></li><li><a href="matlab:web(fullfile(docroot,'matlab/ref/matlab.io.matfile.html'))">matfile</a></li></ul></div><p>Created on October 29. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.</p><p>
<!--
Hidden Clutter.
Edited on Month DD. YYYY by Editor: Single line description.
Edited on November 09. 2020 by Tobias Wulf: Save PathVariables as struct.
Edited on November 09. 2020 by Tobias Wulf: Add Options for dipole simulation with square sensor array.
Edited on December 03. 2020 by Tobias Wulf: Add path and option for KMZ60.
Edited on February 27. 2020 by Tobias Wulf: Add default plot settings.
Edited on February 27. 2020 by Tobias Wulf: Add script as startup task.
-->
</p><h2 id="3">Clean Up</h2><p>Clear variables from workspace to build up a fresh new configuration workspace.</p><pre class="codeinput">disp(<span class="string">'Clean up workspace ...'</span>);
close <span class="string">all</span>;
clearvars;
clc;
</pre><h2 id="4">Default Plot Settings</h2><p>Set default settings for plots and graphics like text interpreter and font size and so on. If script runs on start up, defaults are working for all plots. disp('Set plot defaults ...');</p><pre class="codeinput">set(groot, <span class="string">'DefaultTextInterpreter'</span>, <span class="string">'latex'</span>);
set(groot, <span class="string">'DefaultLegendInterpreter'</span>, <span class="string">'latex'</span>);
set(groot, <span class="string">'DefaultAxesTickLabelInterpreter'</span>, <span class="string">'latex'</span>);
set(groot, <span class="string">'DefaultAxesFontSize'</span>, 20);
set(groot, <span class="string">'DefaultLineLineWidth'</span>,2.5);
set(groot, <span class="string">'DefaultAxesLineWidth'</span>, 1.5);
set(groot, <span class="string">'DefaultAxesFontSize'</span>, 20);
<span class="comment">% set(groot, 'DefaultAxesFontWeight', 'bold');</span>
set(groot, <span class="string">'DefaultTextFontSize'</span>, 20);
<span class="comment">% set(groot, 'DefaultaxesFontName', 'Times new Roman')</span>
<span class="comment">% set(groot, 'DefaultlegendFontName', 'Times new Roman');</span>
set(groot, <span class="string">'DefaultAxesXGrid'</span>,<span class="string">'on'</span>);
set(groot, <span class="string">'DefaultAxesYGrid'</span>,<span class="string">'on'</span>);
set(groot, <span class="string">'DefaultFigureNumberTitle'</span> , <span class="string">'off'</span>);
set(groot, <span class="string">'DefaultFigureWindowStyle'</span>, <span class="string">'normal'</span>);
set(groot, <span class="string">'DefaultFigureMenuBar'</span>, <span class="string">'figure'</span>);
set(groot, <span class="string">'DefaultFigureToolBar'</span>, <span class="string">'figure'</span>);
<span class="comment">% set(groot, 'DefaultFigureUnits', 'centimeters');</span>
set(groot, <span class="string">'DefaultFigurePosition'</span>, [100, 100, 800, 700]);
set(groot, <span class="string">'DefaultFigureWindowState'</span>, <span class="string">'normal'</span>)
set(groot, <span class="string">'DefaultFigurePaperType'</span>, <span class="string">'a4'</span>);
set(groot, <span class="string">'DefaultFigurePaperUnits'</span>, <span class="string">'centimeters'</span>);
set(groot, <span class="string">'DefaultFigurePaperOrientation'</span>, <span class="string">'landscape'</span>);
set(groot, <span class="string">'DefaultFigurePaperPositionMode'</span>, <span class="string">'auto'</span>);
set(groot, <span class="string">'DefaultFigureDoubleBuffer'</span>, <span class="string">'on'</span>);
set(groot, <span class="string">'DefaultFigureRendererMode'</span>, <span class="string">'manual'</span>);
set(groot, <span class="string">'DefaultFigureRenderer'</span>, <span class="string">'painters'</span>);
set(groot, <span class="string">'DefaultTiledlayoutPadding'</span>, <span class="string">'normal'</span>);
set(groot, <span class="string">'DefaultTiledlayoutTileSpacing'</span>, <span class="string">'compact'</span>);
set(groot, <span class="string">'DefaultPolarAxesTickLabelInterpreter'</span>, <span class="string">'latex'</span>);
set(groot, <span class="string">'DefaultPolarAxesFontSize'</span>, 20);
<span class="comment">% set(groot,);</span>
</pre><h2 id="5">GeneralOptions</h2><p>General options like formats for strings or date or anything else what has no special relation to a theme complex. Fix parameters.</p><pre class="codeinput">disp(<span class="string">'Set general options ...'</span>);
GeneralOptions = struct;
GeneralOptions.dateFormat = <span class="string">'yyyy-mm-dd_HH-MM-SS-FFF'</span>;
</pre><h2 id="6">Path Variables</h2><p>Key path variables and directories, often used in functions or scripts. Collet the path in a struct for easier save the struct fields as variables to config.mat via -struct flag. Fix parameters.</p><pre class="codeinput">disp(<span class="string">'Create current project instance to gather information ...'</span>);

<span class="comment">% create current project instance to retrieve root information</span>
projectInstance = matlab.project.currentProject;

disp(<span class="string">'Set path variables ...'</span>);
PathVariables =struct;

<span class="comment">% project root path, needs to be recreated generic to work on</span>
<span class="comment">% different machines</span>
PathVariables.rootPath = projectInstance.RootFolder;

<span class="comment">% path to data folder, which contains datasets and config.mat</span>
PathVariables.dataPath = fullfile(PathVariables.rootPath, <span class="string">'data'</span>);

<span class="comment">% path to TDK TAS2141 TMR angular sensor characterization dataset</span>
PathVariables.tdkDatasetPath = fullfile(PathVariables.dataPath, <span class="keyword">...</span>
    <span class="string">'TDK_TAS2141_Characterization_2020-10-22_18-12-16-827.mat'</span>);

<span class="comment">% path to TDK TAS2141 TMR angular sensor characterization dataset</span>
PathVariables.kmz60DatasetPath = fullfile(PathVariables.dataPath, <span class="keyword">...</span>
    <span class="string">'NXP_KMZ60_Characterization_2020-12-03_16-53-16-721.mat'</span>);

<span class="comment">% path to config file dataset</span>
PathVariables.configPath = fullfile(PathVariables.dataPath, <span class="keyword">...</span>
    <span class="string">'config.mat'</span>);

<span class="comment">% path to training dataset folder</span>
PathVariables.trainingDataPath = fullfile(PathVariables.dataPath, <span class="keyword">...</span>
    <span class="string">'training'</span>);

<span class="comment">% path to test dataset folder</span>
PathVariables.testDataPath = fullfile(PathVariables.dataPath, <span class="keyword">...</span>
    <span class="string">'test'</span>);

<span class="comment">% path to documentation and m-files only for documentation</span>
PathVariables.docsPath = fullfile(PathVariables.rootPath, <span class="keyword">...</span>
    <span class="string">'docs'</span>);

<span class="comment">% path to publish html documentation output directory, helptoc.xml location</span>
PathVariables.publishHtmlPath = fullfile(PathVariables.docsPath, <span class="string">'html'</span>);

<span class="comment">% path to save plots as images svg, eps, png, etc.</span>
PathVariables.saveImagesPath = fullfile(PathVariables.publishHtmlPath, <span class="keyword">...</span>
    <span class="string">'images'</span>);

<span class="comment">% path to latex docs folder</span>
PathVariables.latexDocsPath = fullfile(PathVariables.docsPath, <span class="keyword">...</span>
    <span class="string">'latex'</span>);

<span class="comment">% path to latex Thesis Tobias Wulf (take care if comment in)</span>
<span class="comment">% PathVariables.thesisTobiasWulf = fullfile(PathVariables.latexDocsPath, ...</span>
<span class="comment">%     'BA_Thesis_Tobias_Wulf');</span>

<span class="comment">% path to docs export folder for Manual</span>
PathVariables.exportPublishPath = fullfile(PathVariables.latexDocsPath, <span class="keyword">...</span>
    <span class="string">'Manual'</span>);

<span class="comment">% path to style sheet for html documentation, Matlab provided style sheet</span>
PathVariables.publishStyleSheetPath = fullfile(PathVariables.publishHtmlPath, <span class="keyword">...</span>
    <span class="string">'docsHtmlStyleSheet.xsl'</span>);

<span class="comment">% path to style sheet for latex documentation, Matlab provided style sheet</span>
PathVariables.publishStyleSheetPath2 = fullfile(PathVariables.publishHtmlPath, <span class="keyword">...</span>
    <span class="string">'docsLatexStyleSheet.xsl'</span>);

<span class="comment">% path to documentation search database entries for Matlab help browser support</span>
PathVariables.helpsearchPath = fullfile(PathVariables.publishHtmlPath, <span class="keyword">...</span>
    <span class="string">'helpsearch-v3'</span>);

<span class="comment">% path to executable m-file scripts of the project</span>
PathVariables.scriptsPath = fullfile(PathVariables.rootPath, <span class="string">'scripts'</span>);

<span class="comment">% path to source code files, function and class files</span>
PathVariables.srcPath = fullfile(PathVariables.rootPath, <span class="string">'src'</span>);

<span class="comment">% path to unittest files, scripts and script suite</span>
PathVariables.unittestPath = fullfile(PathVariables.rootPath, <span class="string">'tests'</span>);
</pre><h2 id="7">Publish Options</h2><p>These are general options for documents to publish. They are passed to the matlab publish function via a struct where each option gets its own field. The option struct can be copied and adjusted for differing publish conditions in example for scripts, functions, and bare document m-files. Initialize the option struct with output format field name and field value and add further fields (options) with point value. Fix parameters.</p><pre class="codeinput">disp(<span class="string">'Set publish options struct for publish function ...'</span>);
PublishOptions = struct(<span class="string">'format'</span>, <span class="string">'html'</span>);
PublishOptions.outputDir = PathVariables.publishHtmlPath;
PublishOptions.stylesheet = PathVariables.publishStyleSheetPath;
PublishOptions.createThumbnail = false;
PublishOptions.figureSnapMethod = <span class="string">'entireFigureWindow'</span>;
PublishOptions.imageFormat = <span class="string">'png'</span>;
PublishOptions.maxHeight = 600;
PublishOptions.maxWidth = 600;
PublishOptions.useNewFigure = false;
PublishOptions.evalCode = false;
PublishOptions.catchError = true;
PublishOptions.codeToEvaluate = [];
PublishOptions.maxOutputLines = Inf;
PublishOptions.showCode = true;
</pre><h2 id="8">Sensor Array Options</h2><p>The options control the built-up of the sensor array in geometry and techincal behavior. This means number of sensors in the array and its size in mm. The supply and offset voltage of each sensor which is needed for using the characterization which is normed in mV/V. These parameters should be fix during generation a pulk of training or test data sets. The simulation function does not covers vectors yet.</p><pre class="codeinput">disp(<span class="string">'Set sensor array option for geometry and behavior ...'</span>);
SensorArrayOptions = struct;

<span class="comment">% Geometry of the sensor array current sensor array can be. Fix parameter.</span>
<span class="comment">% square - square sensor array with even distances to each sensor point</span>
SensorArrayOptions.geometry = <span class="string">'square'</span>;

<span class="comment">% Sensor array square dimension. Fix parameter.</span>
SensorArrayOptions.dimension = 8;

<span class="comment">% Sensor array edge length in mm. Fix parameter.</span>
SensorArrayOptions.edge = 2;

<span class="comment">% Sensor array simulated supply voltage in volts. Fix parameter.</span>
SensorArrayOptions.Vcc = 5;

<span class="comment">% Sensor array simulated offset voltage for bridge outputs in volts. Fix</span>
<span class="comment">% paramter.</span>
SensorArrayOptions.Voff = 2.5;

<span class="comment">% Senor array voltage norm factor to recalculate norm bridge outputs to</span>
<span class="comment">% given supply voltage and offset voltage, current normin is mV/V which</span>
<span class="comment">% implements factor of 1e3. Fix paramter.</span>
SensorArrayOptions.Vnorm = 1e3;
</pre><h2 id="9">Dipole Options</h2><p>Dipole options to calculate the magnetic field which stimulate the sensor array. The dipole is gained to sphere with additional z distance to the array by sphere radius. These parameters should be fix during generation a pulk of training or test data sets. The simulation function does not covers vectors yet.</p><pre class="codeinput">disp(<span class="string">'Set dipole options to calculate magnetic stimulus ...'</span>);
DipoleOptions = struct;

<span class="comment">% Radius in mm of magnetic sphere in which the magnetic dipole is centered.</span>
<span class="comment">% So it can be seen as z-offset to the sensor array. Fix parameter.</span>
DipoleOptions.sphereRadius = 2;

<span class="comment">% H-field magnitude to multiply of generated and relative normed dipole</span>
<span class="comment">% H-fields, the norming is done in zero position of [0 0 z0 + sphere radius] for</span>
<span class="comment">% 0 deg due to the position of the magnetic moment [-1 0 0] x and y components</span>
<span class="comment">% are not relevant, norming without tilt. Magnitude in kA/m. The magnitude</span>
<span class="comment">% refers that the sphere magnet has this H-field magnitude in a certain distance</span>
<span class="comment">% z0 in example sphere with 2mm sphere radius has a H magnitude of 200kA/m in</span>
<span class="comment">% 5mm distance. Standard field strength for ferrite sphere magnets are between</span>
<span class="comment">% 180 and 200kA/m. Fix parameter.</span>
DipoleOptions.H0mag = 200;

<span class="comment">% Distance in zero position of the spherical magnet in which the imprinted</span>
<span class="comment">% H-field strength magnitude takes effect. Together with the sphere radius and</span>
<span class="comment">% and the imprinted field strength magnitude the distance in rest position</span>
<span class="comment">% characterizes the spherical magnet to later relative positions of the sensor</span>
<span class="comment">% array and generated dipole H-fields in rotation simulation. In mm. Fix</span>
<span class="comment">% parameter.</span>
DipoleOptions.z0 = 1;

<span class="comment">% Magnetic moment magnitude attach rotation to the dipole field at a</span>
<span class="comment">% certain position with x, y and z components. Choose a huge value to</span>
<span class="comment">% prevent numeric failures, by norming the factor is eleminated later. Fix</span>
<span class="comment">% parameter.</span>
DipoleOptions.M0mag = 1e6;
</pre><h2 id="10">Traning Options</h2><p>Training options gives the software the needed information to generate training datasets by the sensor array simulation with a dipole magnet as stimulus which pushed with an z offset to a sphere.</p><pre class="codeinput">disp(<span class="string">'Set training options to generate dataset ...'</span>);
TrainingOptions = struct;

<span class="comment">% Use case of options define what dataset it is and where to save resulting</span>
<span class="comment">% datasets by simulation function. Fix parameter.</span>
TrainingOptions.useCase = <span class="string">'Training'</span>;

<span class="comment">% Sensor array relative position to dipole magnet as position vector with</span>
<span class="comment">% x, y and z posiotn in mm. Negative x for left shift, negative y for up</span>
<span class="comment">% shift and negative z to place the layer under the dipole decrease z to</span>
<span class="comment">% increase the distance. The z-position will be subtracted by dipole sphere</span>
<span class="comment">% radius in simulation. So there is an offset given by the sphere radius.</span>
<span class="comment">% Loop parameters.</span>
TrainingOptions.xPos = [0,];
TrainingOptions.yPos = [0,];
TrainingOptions.zPos = [7,];

<span class="comment">% Dipole tilt in z-axes in degree. Fix parameter.</span>
TrainingOptions.tilt = 0;

<span class="comment">% Resolution of rotaion in degree, use same resoultion in training and test</span>
<span class="comment">% datasets to have the ability to back reference the index to fullscale</span>
<span class="comment">% test data sets. In degree. Fix parameter.</span>
TrainingOptions.angleRes = 0.5;

<span class="comment">% Phase index applies a phase offset in the rotation, it is used as phase index</span>
<span class="comment">% to a down sampling to generate even distributed angles of a full scale</span>
<span class="comment">% rotation. Offset index of full rotation. In example a full scale rotation from</span>
<span class="comment">% 0 to 360 - angleRes returns 720 angles, if nAngles is set to 7 it returns 7</span>
<span class="comment">% angles [0, 51.5, 103, 154.5, 206, 257.5, 309]. To get a phase shift of 11 set</span>
<span class="comment">% phaseIndex to 22 a multiple of the resolution angleRes and get</span>
<span class="comment">% [11, 62.5, 114, 165.5, 217, 268.5, 320]. Must be positive integer. Fix</span>
<span class="comment">% parameter.</span>
TrainingOptions.phaseIndex = 0;

<span class="comment">% Number rotaion angles, even distribute between 0 and 360 with respect</span>
<span class="comment">% to the resolution, even down sampling. To generate full scale the number</span>
<span class="comment">% relatead to the resolution or fast generate but wrong number set it to 0 to</span>
<span class="comment">% generate full scale rotation too. Fix Parameter.</span>
TrainingOptions.nAngles = 17;

<span class="comment">% Charcterization datset to use in simulation. Current available datasets are</span>
<span class="comment">% TDK - for characterization dataset of TDK TAS2141 TMR sensor</span>
<span class="comment">% KMZ60 - for characterization dataset of NXP KMZ60 AMR sensor</span>
TrainingOptions.BaseReference = <span class="string">'TDK'</span>;

<span class="comment">% Characteraztion field which should be load as refernce image from</span>
<span class="comment">% characterization data set, in TDK dataset are following fields. In the</span>
<span class="comment">% current dataset Rise has the widest linear plateau with a radius of ca.</span>
<span class="comment">% 8.5 kA/m. Fix parameter.</span>
<span class="comment">% Rise - Bridge outputs for rising stimulus amplituded</span>
<span class="comment">% Fall - Bridge outputs for falling stimulus amplitude</span>
<span class="comment">% All  - Superimposed bridge outputs</span>
<span class="comment">% Diff - Differentiated bridge outputs</span>
TrainingOptions.BridgeReference = <span class="string">'Rise'</span>;
</pre><h2 id="11">Test Options</h2><p>Test options gives the software the needed information to generate test datasets by the sensor array simulation with a dipole magnet as stimulus which pushed with an z offset to a sphere.</p><pre class="codeinput">disp(<span class="string">'Set test options to generate dataset ...'</span>);
TestOptions = struct;

<span class="comment">% Use case of options define what dataset it is and where to save resulting</span>
<span class="comment">% datasets by simulation function. Fix Parameter.</span>
TestOptions.useCase = <span class="string">'Test'</span>;

<span class="comment">% Sensor array relative position to dipole magnet as position vector with</span>
<span class="comment">% x, y and z posiotn in mm. Negative x for left shift, negative y for up</span>
<span class="comment">% shift and negative z to place the layer under the dipole decrease z to</span>
<span class="comment">% increase the distance. The z-position will be subtracted by dipole sphere</span>
<span class="comment">% radius in simulation. So there is an offset given by the sphere radius.</span>
<span class="comment">% Loop parameter.</span>
TestOptions.xPos = [0,];
TestOptions.yPos = [0,];
TestOptions.zPos = [7,];

<span class="comment">% Dipole tilt in z-axes in degree. Fix parameter.</span>
TestOptions.tilt = 0;

<span class="comment">% Resolution of rotaion in degree, use same resoultion in training and test</span>
<span class="comment">% datasets to have the ability to back reference the index to fullscale</span>
<span class="comment">% test data sets. In degree. Fix parameter.</span>
TestOptions.angleRes = 0.5;

<span class="comment">% Phase index applies a phase offset in the rotation, it is used as phase index</span>
<span class="comment">% to a down sampling to generate even distributed angles of a full scale</span>
<span class="comment">% rotation. Offset index of full rotation. In example a full scale rotation from</span>
<span class="comment">% 0 to 360 - angleRes returns 720 angles, if nAngles is set to 7 it returns 7</span>
<span class="comment">% angles [0, 51.5, 103, 154.5, 206, 257.5, 309]. To get a phase shift of 11 set</span>
<span class="comment">% phaseIndex to 22 a multiple of the resolution angleRes and get</span>
<span class="comment">% [11, 62.5, 114, 165.5, 217, 268.5, 320]. Must be positive integer. Fix</span>
<span class="comment">% parameter.</span>
TestOptions.phaseIndex = 0;

<span class="comment">% Number rotaion angles, even distribute between 0 and 360 with respect</span>
<span class="comment">% to the resolution, even down sampling. To generate full scale the number</span>
<span class="comment">% relatead to the resolution or fast generate but wrong number to 0 to</span>
<span class="comment">% generate full scale rotation. Fix parameter.</span>
TestOptions.nAngles = 720;

<span class="comment">% Charcterization datset to use in simulation. Current available datasets are</span>
<span class="comment">% TDK - for characterization dataset of TDK TAS2141 TMR sensor</span>
<span class="comment">% KMZ60 - for characterization dataset of NXP KMZ60 AMR sensor</span>
TestOptions.BaseReference = <span class="string">'TDK'</span>;

<span class="comment">% Characteraztion field which should be load as refernce image from</span>
<span class="comment">% characterization data set, in TDK dataset are following fields. In the</span>
<span class="comment">% current dataset Rise has the widest linear plateau with a radius of ca.</span>
<span class="comment">% 8.5 kA/m. Fix parameter.</span>
<span class="comment">% Rise - Bridge outputs for rising stimulus amplituded</span>
<span class="comment">% Fall - Bridge outputs for falling stimulus amplitude</span>
<span class="comment">% All  - Superimposed bridge outputs</span>
<span class="comment">% Diff - Differentiated bridge outputs</span>
TestOptions.BridgeReference = <span class="string">'Rise'</span>;
</pre><h2 id="12">GPR Options</h2><p>Gaussian Process Regression options to generate a regression model for angular prediction and analyzing the accuracy of the prediction. The GPR model uses one certain covariance function to compute the prediction but it is possible to initiate as zero mean GPR without mean correction and a simple mean function which supports offset amplitude correction of the sinoid inputs for cosine and sine. The GPR uses a quadratic frobnius norm covariance function. That function has two kernel parameters s2f as variance parameter and sl as length scale parameter. Additional a noise variance s2n must be passed to GPR to compute noisy observations.</p><pre class="codeinput">disp(<span class="string">'Set test options to generate GPR model ...'</span>);
GPROptions = struct();

<span class="comment">% Set kernel function to compute covariance matrix, vectors or test point</span>
<span class="comment">% covariance. Current available covariance functions are:</span>
<span class="comment">% QFC    - Quadratic Frobenius Covariance with excact distance.</span>
<span class="comment">% QFCAPX - Quadratic Frobenius Covariance with approximated distance of triangle</span>
<span class="comment">%          inequation of matrix norm, minimizes training data to a vector.</span>
GPROptions.kernel = <span class="string">'QFCAPX'</span>;

<span class="comment">% Initial theta values as vector of [s2f, sl] variance and length scale</span>
<span class="comment">% parameter of the quadratic frobenius covariance function. Empirical</span>
<span class="comment">% tested start values are the sensor array dimension as length scale and a small</span>
<span class="comment">% value as variance factor. Set variance bounds to 1 for 1 on the diagonal of</span>
<span class="comment">% the covariance matrix. Only sl will be tuned in the process. Set sf2 not one</span>
<span class="comment">% it will be tuned both. Tuning both the vertical scale s2f and horizontal scale</span>
<span class="comment">% 2*sl^2 can lead to inbalance of cosine and sine prediction indicated by</span>
<span class="comment">% diverging log likelihoods for cosine and sine prediction.</span>
<span class="comment">%                  [s2f , sl]</span>
GPROptions.theta = [1, 1];

<span class="comment">% Set lower and upper bounds to optimize kernel parameters theta which is a</span>
<span class="comment">% vector of covariance parameter covariance variance parameter s2f and lenght</span>
<span class="comment">% scale parameter sl. These bounds must be set to prevent an overfitting in</span>
<span class="comment">% tuning the kernel parameter. If the bounds are to tight in relation of datset</span>
<span class="comment">% number in variation the prediction losses its generalization.</span>
<span class="comment">% If the bounds are to tight in generel the tuning and optimization procedure</span>
<span class="comment">% cannot dismiss bad set points and tries to reach them over and over,</span>
<span class="comment">% the causes a limitting which would be break through if the procedure reaches</span>
<span class="comment">% the point evaluated as bad set point. If the bound are to wide in relation of</span>
<span class="comment">% number in dataset variousity the mean error raises. The model is to complex</span>
<span class="comment">% then. Try to keep up simple modles.</span>
GPROptions.s2fBounds = [0.1, 100];
GPROptions.slBounds = [0.1, 100];

<span class="comment">% Set initial noise variance to add noise along the diagonal of th covariance</span>
<span class="comment">% matrix to predict noisy observation. Set to small values or even 0 to get</span>
<span class="comment">% noise free observations.</span>
GPROptions.s2n = 1e-04;

<span class="comment">% Set lower and upper bounds for noise adjustment in computing the covariance</span>
<span class="comment">% matrix for noisy observations. These bounds prevent the GPR of overfitting in</span>
<span class="comment">% the noise optimization procedure. The default noise at initialization is 1e-5.</span>
GPROptions.s2nBounds = [1e-10, 1e-4];


<span class="comment">% Set number of outer optimization runs. For wide parameter bounds it is</span>
<span class="comment">% recommended to set the number of runs to min 30 otherwise the bayes</span>
<span class="comment">% optimization runs to short in finding error bounds and left with not good</span>
<span class="comment">% optimized parameters.</span>
GPROptions.OptimRuns = 20;


<span class="comment">% Set standardized logarithmic loss for bayes optimization of s2n with MSLL.</span>
<span class="comment">% MSLL resutls as mean of chosen SLL.</span>
<span class="comment">% SLLA - loss by simulation angles</span>
<span class="comment">% SLLR - loss by radius = 1 (unit circle)</span>
GPROptions.SLL = <span class="string">'SLLA'</span>;

<span class="comment">% Enables mean function and offset and amplitude correction.</span>
<span class="comment">% Set basis function to compute H matrix of training points and h vector of</span>
<span class="comment">% test point. Current availible basis function are:</span>
<span class="comment">% zero - init GPR as zero mean GPR m(x) = 0</span>
<span class="comment">% poly - init GPR with mean correction m(x) = H' * beta, where H is a matrix</span>
<span class="comment">%        polynom mean vectors at each observation points</span>
<span class="comment">%        h(x) = [1; x; x^2; x^3; ...] and beta are coefficients of the polynom.</span>
<span class="comment">%        For QFC kernel x = ||X||_F</span>
GPROptions.mean = <span class="string">'zero'</span>;

<span class="comment">% Polynom degree for mean poly degree option 0 for constanat, 1 for 1 + x,</span>
<span class="comment">% 2 fo 1 + x + x^2 and so on. Takes only effects if mean = 'poly'. Maximum</span>
<span class="comment">% polynom degree is 7.</span>
GPROptions.polyDegree = 1;
</pre><h2 id="13">Save Configuration</h2><p>Save section wise each config part as struct to standalone variables in config.mat use newest save format with no compression. create config.mat with timestamp.</p><pre class="codeinput">disp(<span class="string">'Create config.mat ...'</span>);
timestamp = datestr(now, GeneralOptions.dateFormat);
save(PathVariables.configPath, <span class="keyword">...</span>
    <span class="string">'timestamp'</span>, <span class="keyword">...</span>
    <span class="string">'GeneralOptions'</span>, <span class="keyword">...</span>
    <span class="string">'PathVariables'</span>, <span class="keyword">...</span>
    <span class="string">'PublishOptions'</span>, <span class="keyword">...</span>
    <span class="string">'SensorArrayOptions'</span>, <span class="keyword">...</span>
    <span class="string">'DipoleOptions'</span>, <span class="keyword">...</span>
    <span class="string">'TrainingOptions'</span>, <span class="keyword">...</span>
    <span class="string">'TestOptions'</span>, <span class="keyword">...</span>
    <span class="string">'GPROptions'</span>, <span class="keyword">...</span>
    <span class="string">'-v7.3'</span>, <span class="string">'-nocompression'</span>);
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% generateConfigMat
% Generate configuration mat-file wich contains reusable configuration to
% control the software or certain function parameters. Centralized collection of
% configuration. If it is certain configuration needed place it here.
%
%
%% Requirements
% * Other m-files required: None
% * Subfunctions: None
% * MAT-files required: None
%
%
%% See Also
% * <matlab:web(fullfile(docroot,'matlab/ref/save.html')) save>
% * <matlab:web(fullfile(docroot,'matlab/ref/load.html')) load>
% * <matlab:web(fullfile(docroot,'matlab/ref/matlab.io.matfile.html')) matfile>
%
%
% Created on October 29. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on Month DD. YYYY by Editor: Single line description.
% Edited on November 09. 2020 by Tobias Wulf: Save PathVariables as struct.
% Edited on November 09. 2020 by Tobias Wulf: Add Options for dipole simulation with square sensor array.
% Edited on December 03. 2020 by Tobias Wulf: Add path and option for KMZ60.
% Edited on February 27. 2020 by Tobias Wulf: Add default plot settings.
% Edited on February 27. 2020 by Tobias Wulf: Add script as startup task.
% REPLACE_WITH_DASH_DASH>
% </html>
%
%
%% Clean Up
% Clear variables from workspace to build up a fresh new configuration
% workspace.
disp('Clean up workspace ...');
close all;
clearvars;
clc;


%% Default Plot Settings
% Set default settings for plots and graphics like text interpreter and font
% size and so on. If script runs on start up, defaults are working for all
% plots.
% disp('Set plot defaults ...');
set(groot, 'DefaultTextInterpreter', 'latex');
set(groot, 'DefaultLegendInterpreter', 'latex');
set(groot, 'DefaultAxesTickLabelInterpreter', 'latex');
set(groot, 'DefaultAxesFontSize', 20);
set(groot, 'DefaultLineLineWidth',2.5);
set(groot, 'DefaultAxesLineWidth', 1.5);
set(groot, 'DefaultAxesFontSize', 20);
% set(groot, 'DefaultAxesFontWeight', 'bold');
set(groot, 'DefaultTextFontSize', 20);
% set(groot, 'DefaultaxesFontName', 'Times new Roman') 
% set(groot, 'DefaultlegendFontName', 'Times new Roman');
set(groot, 'DefaultAxesXGrid','on');
set(groot, 'DefaultAxesYGrid','on'); 
set(groot, 'DefaultFigureNumberTitle' , 'off');
set(groot, 'DefaultFigureWindowStyle', 'normal');
set(groot, 'DefaultFigureMenuBar', 'figure');
set(groot, 'DefaultFigureToolBar', 'figure');
% set(groot, 'DefaultFigureUnits', 'centimeters');
set(groot, 'DefaultFigurePosition', [100, 100, 800, 700]);
set(groot, 'DefaultFigureWindowState', 'normal')
set(groot, 'DefaultFigurePaperType', 'a4');
set(groot, 'DefaultFigurePaperUnits', 'centimeters');
set(groot, 'DefaultFigurePaperOrientation', 'landscape');
set(groot, 'DefaultFigurePaperPositionMode', 'auto');
set(groot, 'DefaultFigureDoubleBuffer', 'on');
set(groot, 'DefaultFigureRendererMode', 'manual');
set(groot, 'DefaultFigureRenderer', 'painters');
set(groot, 'DefaultTiledlayoutPadding', 'normal');
set(groot, 'DefaultTiledlayoutTileSpacing', 'compact');
set(groot, 'DefaultPolarAxesTickLabelInterpreter', 'latex');
set(groot, 'DefaultPolarAxesFontSize', 20);
% set(groot,);

%% GeneralOptions
% General options like formats for strings or date or anything else what
% has no special relation to a theme complex. Fix parameters.
disp('Set general options ...');
GeneralOptions = struct;
GeneralOptions.dateFormat = 'yyyy-mm-dd_HH-MM-SS-FFF';


%% Path Variables
% Key path variables and directories, often used in functions or scripts.
% Collet the path in a struct for easier save the struct fields as
% variables to config.mat via -struct flag. Fix parameters.

disp('Create current project instance to gather information ...');

% create current project instance to retrieve root information
projectInstance = matlab.project.currentProject;

disp('Set path variables ...');
PathVariables =struct;

% project root path, needs to be recreated generic to work on 
% different machines
PathVariables.rootPath = projectInstance.RootFolder;

% path to data folder, which contains datasets and config.mat
PathVariables.dataPath = fullfile(PathVariables.rootPath, 'data');

% path to TDK TAS2141 TMR angular sensor characterization dataset
PathVariables.tdkDatasetPath = fullfile(PathVariables.dataPath, ... 
    'TDK_TAS2141_Characterization_2020-10-22_18-12-16-827.mat');

% path to TDK TAS2141 TMR angular sensor characterization dataset
PathVariables.kmz60DatasetPath = fullfile(PathVariables.dataPath, ... 
    'NXP_KMZ60_Characterization_2020-12-03_16-53-16-721.mat');

% path to config file dataset
PathVariables.configPath = fullfile(PathVariables.dataPath, ...
    'config.mat');

% path to training dataset folder
PathVariables.trainingDataPath = fullfile(PathVariables.dataPath, ...
    'training');

% path to test dataset folder
PathVariables.testDataPath = fullfile(PathVariables.dataPath, ...
    'test');

% path to documentation and m-files only for documentation
PathVariables.docsPath = fullfile(PathVariables.rootPath, ...
    'docs');

% path to publish html documentation output directory, helptoc.xml location
PathVariables.publishHtmlPath = fullfile(PathVariables.docsPath, 'html');

% path to save plots as images svg, eps, png, etc.
PathVariables.saveImagesPath = fullfile(PathVariables.publishHtmlPath, ...
    'images');

% path to latex docs folder
PathVariables.latexDocsPath = fullfile(PathVariables.docsPath, ...
    'latex');

% path to latex Thesis Tobias Wulf (take care if comment in)
% PathVariables.thesisTobiasWulf = fullfile(PathVariables.latexDocsPath, ...
%     'BA_Thesis_Tobias_Wulf');

% path to docs export folder for Manual
PathVariables.exportPublishPath = fullfile(PathVariables.latexDocsPath, ...
    'Manual');

% path to style sheet for html documentation, Matlab provided style sheet
PathVariables.publishStyleSheetPath = fullfile(PathVariables.publishHtmlPath, ...
    'docsHtmlStyleSheet.xsl');

% path to style sheet for latex documentation, Matlab provided style sheet
PathVariables.publishStyleSheetPath2 = fullfile(PathVariables.publishHtmlPath, ...
    'docsLatexStyleSheet.xsl');

% path to documentation search database entries for Matlab help browser support
PathVariables.helpsearchPath = fullfile(PathVariables.publishHtmlPath, ...
    'helpsearch-v3');

% path to executable m-file scripts of the project
PathVariables.scriptsPath = fullfile(PathVariables.rootPath, 'scripts');

% path to source code files, function and class files
PathVariables.srcPath = fullfile(PathVariables.rootPath, 'src');

% path to unittest files, scripts and script suite
PathVariables.unittestPath = fullfile(PathVariables.rootPath, 'tests');


%% Publish Options
% These are general options for documents to publish. They are passed to the
% matlab publish function via a struct where each option gets its own field.
% The option struct can be copied and adjusted for differing publish
% conditions in example for scripts, functions, and bare document m-files.
% Initialize the option struct with output format field name and field value
% and add further fields (options) with point value. Fix parameters.
disp('Set publish options struct for publish function ...');
PublishOptions = struct('format', 'html');
PublishOptions.outputDir = PathVariables.publishHtmlPath;
PublishOptions.stylesheet = PathVariables.publishStyleSheetPath;
PublishOptions.createThumbnail = false;
PublishOptions.figureSnapMethod = 'entireFigureWindow';
PublishOptions.imageFormat = 'png';
PublishOptions.maxHeight = 600;
PublishOptions.maxWidth = 600;
PublishOptions.useNewFigure = false;
PublishOptions.evalCode = false;
PublishOptions.catchError = true;
PublishOptions.codeToEvaluate = [];
PublishOptions.maxOutputLines = Inf;
PublishOptions.showCode = true;


%% Sensor Array Options
% The options control the built-up of the sensor array in geometry and
% techincal behavior. This means number of sensors in the array and its
% size in mm. The supply and offset voltage of each sensor which is needed
% for using the characterization which is normed in mV/V. These parameters
% should be fix during generation a pulk of training or test data sets. The
% simulation function does not covers vectors yet.
disp('Set sensor array option for geometry and behavior ...');
SensorArrayOptions = struct;

% Geometry of the sensor array current sensor array can be. Fix parameter.
% square - square sensor array with even distances to each sensor point
SensorArrayOptions.geometry = 'square';

% Sensor array square dimension. Fix parameter.
SensorArrayOptions.dimension = 8;

% Sensor array edge length in mm. Fix parameter.
SensorArrayOptions.edge = 2;

% Sensor array simulated supply voltage in volts. Fix parameter.
SensorArrayOptions.Vcc = 5;

% Sensor array simulated offset voltage for bridge outputs in volts. Fix
% paramter.
SensorArrayOptions.Voff = 2.5;

% Senor array voltage norm factor to recalculate norm bridge outputs to
% given supply voltage and offset voltage, current normin is mV/V which
% implements factor of 1e3. Fix paramter.
SensorArrayOptions.Vnorm = 1e3;


%% Dipole Options
% Dipole options to calculate the magnetic field which stimulate the sensor
% array. The dipole is gained to sphere with additional z distance to the
% array by sphere radius. These parameters should be fix during generation
% a pulk of training or test data sets. The simulation function does not
% covers vectors yet.
disp('Set dipole options to calculate magnetic stimulus ...');
DipoleOptions = struct;

% Radius in mm of magnetic sphere in which the magnetic dipole is centered.
% So it can be seen as z-offset to the sensor array. Fix parameter.
DipoleOptions.sphereRadius = 2;

% H-field magnitude to multiply of generated and relative normed dipole
% H-fields, the norming is done in zero position of [0 0 z0 + sphere radius] for
% 0 deg due to the position of the magnetic moment [-1 0 0] x and y components
% are not relevant, norming without tilt. Magnitude in kA/m. The magnitude
% refers that the sphere magnet has this H-field magnitude in a certain distance
% z0 in example sphere with 2mm sphere radius has a H magnitude of 200kA/m in
% 5mm distance. Standard field strength for ferrite sphere magnets are between
% 180 and 200kA/m. Fix parameter.
DipoleOptions.H0mag = 200;

% Distance in zero position of the spherical magnet in which the imprinted
% H-field strength magnitude takes effect. Together with the sphere radius and
% and the imprinted field strength magnitude the distance in rest position
% characterizes the spherical magnet to later relative positions of the sensor
% array and generated dipole H-fields in rotation simulation. In mm. Fix
% parameter.
DipoleOptions.z0 = 1;

% Magnetic moment magnitude attach rotation to the dipole field at a
% certain position with x, y and z components. Choose a huge value to
% prevent numeric failures, by norming the factor is eleminated later. Fix
% parameter.
DipoleOptions.M0mag = 1e6;


%% Traning Options
% Training options gives the software the needed information to generate
% training datasets by the sensor array simulation with a dipole magnet as
% stimulus which pushed with an z offset to a sphere.
disp('Set training options to generate dataset ...');
TrainingOptions = struct;

% Use case of options define what dataset it is and where to save resulting
% datasets by simulation function. Fix parameter.
TrainingOptions.useCase = 'Training';

% Sensor array relative position to dipole magnet as position vector with
% x, y and z posiotn in mm. Negative x for left shift, negative y for up
% shift and negative z to place the layer under the dipole decrease z to
% increase the distance. The z-position will be subtracted by dipole sphere
% radius in simulation. So there is an offset given by the sphere radius.
% Loop parameters.
TrainingOptions.xPos = [0,];
TrainingOptions.yPos = [0,];
TrainingOptions.zPos = [7,];

% Dipole tilt in z-axes in degree. Fix parameter.
TrainingOptions.tilt = 0;

% Resolution of rotaion in degree, use same resoultion in training and test
% datasets to have the ability to back reference the index to fullscale
% test data sets. In degree. Fix parameter.
TrainingOptions.angleRes = 0.5;

% Phase index applies a phase offset in the rotation, it is used as phase index
% to a down sampling to generate even distributed angles of a full scale
% rotation. Offset index of full rotation. In example a full scale rotation from
% 0 to 360 - angleRes returns 720 angles, if nAngles is set to 7 it returns 7
% angles [0, 51.5, 103, 154.5, 206, 257.5, 309]. To get a phase shift of 11 set
% phaseIndex to 22 a multiple of the resolution angleRes and get
% [11, 62.5, 114, 165.5, 217, 268.5, 320]. Must be positive integer. Fix
% parameter.
TrainingOptions.phaseIndex = 0;

% Number rotaion angles, even distribute between 0 and 360 with respect
% to the resolution, even down sampling. To generate full scale the number
% relatead to the resolution or fast generate but wrong number set it to 0 to
% generate full scale rotation too. Fix Parameter.
TrainingOptions.nAngles = 17;

% Charcterization datset to use in simulation. Current available datasets are
% TDK - for characterization dataset of TDK TAS2141 TMR sensor
% KMZ60 - for characterization dataset of NXP KMZ60 AMR sensor
TrainingOptions.BaseReference = 'TDK';

% Characteraztion field which should be load as refernce image from
% characterization data set, in TDK dataset are following fields. In the
% current dataset Rise has the widest linear plateau with a radius of ca.
% 8.5 kA/m. Fix parameter.
% Rise - Bridge outputs for rising stimulus amplituded
% Fall - Bridge outputs for falling stimulus amplitude
% All  - Superimposed bridge outputs
% Diff - Differentiated bridge outputs
TrainingOptions.BridgeReference = 'Rise';


%% Test Options
% Test options gives the software the needed information to generate
% test datasets by the sensor array simulation with a dipole magnet as
% stimulus which pushed with an z offset to a sphere.
disp('Set test options to generate dataset ...');
TestOptions = struct;

% Use case of options define what dataset it is and where to save resulting
% datasets by simulation function. Fix Parameter.
TestOptions.useCase = 'Test';

% Sensor array relative position to dipole magnet as position vector with
% x, y and z posiotn in mm. Negative x for left shift, negative y for up
% shift and negative z to place the layer under the dipole decrease z to
% increase the distance. The z-position will be subtracted by dipole sphere
% radius in simulation. So there is an offset given by the sphere radius.
% Loop parameter.
TestOptions.xPos = [0,];
TestOptions.yPos = [0,];
TestOptions.zPos = [7,];

% Dipole tilt in z-axes in degree. Fix parameter.
TestOptions.tilt = 0;

% Resolution of rotaion in degree, use same resoultion in training and test
% datasets to have the ability to back reference the index to fullscale
% test data sets. In degree. Fix parameter.
TestOptions.angleRes = 0.5;

% Phase index applies a phase offset in the rotation, it is used as phase index
% to a down sampling to generate even distributed angles of a full scale
% rotation. Offset index of full rotation. In example a full scale rotation from
% 0 to 360 - angleRes returns 720 angles, if nAngles is set to 7 it returns 7
% angles [0, 51.5, 103, 154.5, 206, 257.5, 309]. To get a phase shift of 11 set
% phaseIndex to 22 a multiple of the resolution angleRes and get
% [11, 62.5, 114, 165.5, 217, 268.5, 320]. Must be positive integer. Fix
% parameter.
TestOptions.phaseIndex = 0;

% Number rotaion angles, even distribute between 0 and 360 with respect
% to the resolution, even down sampling. To generate full scale the number
% relatead to the resolution or fast generate but wrong number to 0 to
% generate full scale rotation. Fix parameter.
TestOptions.nAngles = 720;

% Charcterization datset to use in simulation. Current available datasets are
% TDK - for characterization dataset of TDK TAS2141 TMR sensor
% KMZ60 - for characterization dataset of NXP KMZ60 AMR sensor
TestOptions.BaseReference = 'TDK';

% Characteraztion field which should be load as refernce image from
% characterization data set, in TDK dataset are following fields. In the
% current dataset Rise has the widest linear plateau with a radius of ca.
% 8.5 kA/m. Fix parameter.
% Rise - Bridge outputs for rising stimulus amplituded
% Fall - Bridge outputs for falling stimulus amplitude
% All  - Superimposed bridge outputs
% Diff - Differentiated bridge outputs
TestOptions.BridgeReference = 'Rise';


%% GPR Options
% Gaussian Process Regression options to generate a regression model for angular
% prediction and analyzing the accuracy of the prediction. The GPR model uses
% one certain covariance function to compute the prediction but it is possible
% to initiate as zero mean GPR without mean correction and a simple mean
% function which supports offset amplitude correction of the sinoid inputs for
% cosine and sine. The GPR uses a quadratic frobnius norm covariance function.
% That function has two kernel parameters s2f as variance parameter and sl as
% length scale parameter. Additional a noise variance s2n must be passed to GPR
% to compute noisy observations.
disp('Set test options to generate GPR model ...');
GPROptions = struct();

% Set kernel function to compute covariance matrix, vectors or test point
% covariance. Current available covariance functions are:
% QFC    - Quadratic Frobenius Covariance with excact distance.
% QFCAPX - Quadratic Frobenius Covariance with approximated distance of triangle
%          inequation of matrix norm, minimizes training data to a vector.
GPROptions.kernel = 'QFCAPX';

% Initial theta values as vector of [s2f, sl] variance and length scale
% parameter of the quadratic frobenius covariance function. Empirical 
% tested start values are the sensor array dimension as length scale and a small
% value as variance factor. Set variance bounds to 1 for 1 on the diagonal of
% the covariance matrix. Only sl will be tuned in the process. Set sf2 not one
% it will be tuned both. Tuning both the vertical scale s2f and horizontal scale
% 2*sl^2 can lead to inbalance of cosine and sine prediction indicated by
% diverging log likelihoods for cosine and sine prediction.
%                  [s2f , sl]
GPROptions.theta = [1, 1];

% Set lower and upper bounds to optimize kernel parameters theta which is a
% vector of covariance parameter covariance variance parameter s2f and lenght
% scale parameter sl. These bounds must be set to prevent an overfitting in
% tuning the kernel parameter. If the bounds are to tight in relation of datset
% number in variation the prediction losses its generalization. 
% If the bounds are to tight in generel the tuning and optimization procedure
% cannot dismiss bad set points and tries to reach them over and over, 
% the causes a limitting which would be break through if the procedure reaches 
% the point evaluated as bad set point. If the bound are to wide in relation of
% number in dataset variousity the mean error raises. The model is to complex
% then. Try to keep up simple modles.
GPROptions.s2fBounds = [0.1, 100];
GPROptions.slBounds = [0.1, 100];

% Set initial noise variance to add noise along the diagonal of th covariance
% matrix to predict noisy observation. Set to small values or even 0 to get
% noise free observations.
GPROptions.s2n = 1e-04;

% Set lower and upper bounds for noise adjustment in computing the covariance
% matrix for noisy observations. These bounds prevent the GPR of overfitting in
% the noise optimization procedure. The default noise at initialization is 1e-5.
GPROptions.s2nBounds = [1e-10, 1e-4];


% Set number of outer optimization runs. For wide parameter bounds it is
% recommended to set the number of runs to min 30 otherwise the bayes
% optimization runs to short in finding error bounds and left with not good
% optimized parameters.
GPROptions.OptimRuns = 20;


% Set standardized logarithmic loss for bayes optimization of s2n with MSLL.
% MSLL resutls as mean of chosen SLL.
% SLLA - loss by simulation angles
% SLLR - loss by radius = 1 (unit circle)
GPROptions.SLL = 'SLLA';

% Enables mean function and offset and amplitude correction. 
% Set basis function to compute H matrix of training points and h vector of
% test point. Current availible basis function are:
% zero - init GPR as zero mean GPR m(x) = 0
% poly - init GPR with mean correction m(x) = H' * beta, where H is a matrix
%        polynom mean vectors at each observation points 
%        h(x) = [1; x; x^2; x^3; ...] and beta are coefficients of the polynom.
%        For QFC kernel x = ||X||_F
GPROptions.mean = 'zero';

% Polynom degree for mean poly degree option 0 for constanat, 1 for 1 + x,
% 2 fo 1 + x + x^2 and so on. Takes only effects if mean = 'poly'. Maximum
% polynom degree is 7.
GPROptions.polyDegree = 1;


%% Save Configuration
% Save section wise each config part as struct to standalone variables in
% config.mat use newest save format with no compression.
% create config.mat with timestamp.
disp('Create config.mat ...');
timestamp = datestr(now, GeneralOptions.dateFormat);
save(PathVariables.configPath, ...
    'timestamp', ...
    'GeneralOptions', ...
    'PathVariables', ...
    'PublishOptions', ... 
    'SensorArrayOptions', ... 
    'DipoleOptions', ...
    'TrainingOptions', ... 
    'TestOptions', ...
    'GPROptions', ...
    '-v7.3', '-nocompression');

##### SOURCE END #####
--></body></html>