
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: {extensions: ["mhchem.js"]},
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: true
            },
            CommonHTML: {minScaleAdjust: 110,},
            "HTML-CSS": {
                availableFonts: ["TeX"],
                scale: 110
            }
        });
        
    </script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>computeDipoleHField</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-12-10"><meta name="DC.source" content="computeDipoleHField.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>computeDipoleHField</h1><!--introduction--><p>Computes the magnetic field strength H of a dipole magnet dependent of position and magnetic moment and imprint a field strength magnitude on the resultating field by passing a norm factor which relates to the rest position of the dipole magnet. The resultating field strength has field components in x, y and z direction.</p><p>The magnetic dipole moment w must be a column vector or shape</p><p><span class="MathJax_Preview"><img src="computeDipoleHField_eq01305638310057075822.png" alt="$$\vec{m} = \left[ \matrix{m_x \cr m_y \cr m_z} \right]$$"></span><script type="math/tex">\vec{m} = \left[ \matrix{m_x \cr m_y \cr m_z} \right]</script></p><p>so that the magnetic moment corresponds to a position vector</p><p><span class="MathJax_Preview"><img src="computeDipoleHField_eq16534708260388191803.png" alt="$$\vec{r} = \left[ \matrix{x \cr y \cr z} \right]$$"></span><script type="math/tex">\vec{r} = \left[ \matrix{x \cr y \cr z} \right]</script></p><p>with coordinates for x, y and z in 3D coordinate system which can be taken part of its unit vector and its magnitude.</p><p><span class="MathJax_Preview"><img src="computeDipoleHField_eq00445117415567646512.png" alt="$$\vec{r} = \hat{r} \cdot |\vec{r}|$$"></span><script type="math/tex">\vec{r} = \hat{r} \cdot |\vec{r}|</script></p><p>It computes the field strenght at this position with the current magnetic moment for field compents in the same orientation.</p><p><span class="MathJax_Preview"><img src="computeDipoleHField_eq05368340117040415818.png" alt="$$\vec{H}(\vec{r}) = \left[ \matrix{H_x \cr H_y \cr H_z} \right]$$"></span><script type="math/tex">\vec{H}(\vec{r}) = \left[ \matrix{H_x \cr H_y \cr H_z} \right]</script></p><p>The originally equation of the magnetic dipole is known as</p><p><span class="MathJax_Preview"><img src="computeDipoleHField_eq10946700800078040278.png" alt="$$\vec{H}(\vec{r}) = \frac{\vec{B}(\vec{r})}{\mu_0}$$"></span><script type="math/tex">\vec{H}(\vec{r}) = \frac{\vec{B}(\vec{r})}{\mu_0}</script></p><p><span class="MathJax_Preview"><img src="computeDipoleHField_eq17540098048985189210.png" alt="$$\vec{H}(\vec{r}) = \frac{1}{4\pi} \cdot&#xA;\frac{3\vec{r}\cdot(\vec{m}^T\cdot\vec{r}) - \vec{m}\cdot|\vec{r}|^2}{|\vec{r}|^5}$$"></span><script type="math/tex">\vec{H}(\vec{r}) = \frac{1}{4\pi} \cdot
\frac{3\vec{r}\cdot(\vec{m}^T\cdot\vec{r}) - \vec{m}\cdot|\vec{r}|^2}{|\vec{r}|^5}</script></p><p>which can be simplified by putting in the unit vector of the position in into the equation.</p><p><span class="MathJax_Preview"><img src="computeDipoleHField_eq06276819131034202160.png" alt="$$\vec{H}(\vec{r}) = \frac{1}{4\pi|\vec{r}|^3} \cdot&#xA;\big(3\hat{r}\cdot(\vec{m}^T\cdot\hat{r}) - \vec{m}\big)$$"></span><script type="math/tex">\vec{H}(\vec{r}) = \frac{1}{4\pi|\vec{r}|^3} \cdot
\big(3\hat{r}\cdot(\vec{m}^T\cdot\hat{r}) - \vec{m}\big)</script></p><p>To imprint a certain field strength related to a rest position of the dipole the resulting field strength is multiplied with a norming factor. The factor must be computed with same magnitude of the magnetic dipole moments which is passed to this computation to get correct field strengths. To get fields without imprinting set the norming factor to 1.</p><p><span class="MathJax_Preview"><img src="computeDipoleHField_eq16137640578835637442.png" alt="$$\vec{H}(\vec{r}) \cdot H_{0norm}$$"></span><script type="math/tex">\vec{H}(\vec{r}) \cdot H_{0norm}</script></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Examples</a></li><li><a href="#4">Input Argurments</a></li><li><a href="#5">Output Argurments</a></li><li><a href="#6">Requirements</a></li><li><a href="#7">See Also</a></li></ul></div><h2 id="1">Syntax</h2><pre class="language-matlab">H = computeDipoleHField(x, y, z, m, H0norm)
</pre><h2 id="2">Description</h2><p><b>H = computeDipoleHField(x, y, z, m, H0norm)</b> compute dipole field strength at passed position (x,y,z) with the magnetic dipole moment m. The resulting field strenght is a vector with components in x, y and z direction. A field strength norming is imprinted on a rest position computation and multiplied on the result by multiplying a norm factor to the field. The normfactor must be relate to the same magnitude of the magnetic dipole moment which is used here and correspond to the magnets rest position in defined distance of the magnets surface.</p><h2 id="3">Examples</h2><pre class="language-matlab"><span class="comment">% compute a single point without norming</span>
H = computeDipoleHField(1, 2, 3, [1; 0; 0], 1)
</pre><pre class="language-matlab"><span class="comment">% compute a 3D grid of positions</span>
x = linspace(-10, 10, 40);
y = linspace(10, -10, 40);
z = linspace(10, -10, 40);
[X, Y, Z] = meshgrid(x, y, z);
</pre><pre class="language-matlab"><span class="comment">% allocate memory for field components in x,y,z</span>
Hx = zeros(40, 40, 40);
Hy = zeros(40, 40, 40);
Hz = zeros(40, 40, 40);
</pre><pre class="language-matlab"><span class="comment">% compute without norming for each z layer and reshape results into layer</span>
<span class="comment">% magnetic moments points in -x direction which implies north and south pole</span>
<span class="comment">% is in x direction and rotation axes in z</span>
<span class="keyword">for</span> i=1:40
    H = computeDipoleHField(X(:,:,i),Y(:,:,i),Z(:,:,i),[-1;0;0],1);
    Hx(:,:,i) = reshape(H(1,:),40,40);
    Hy(:,:,i) = reshape(H(2,:),40,40);
    Hz(:,:,i) = reshape(H(3,:),40,40);
<span class="keyword">end</span>
</pre><pre class="language-matlab"><span class="comment">% calculate magnitude in each point for better view the results</span>
Habs = sqrt(Hx.^2+Hy.^2+Hz.^2);
</pre><pre class="language-matlab"><span class="comment">% define a index to view only every 4th point for not overcrowded plot</span>
idx = 1:4:40;
</pre><pre class="language-matlab"><span class="comment">% downsample and norm</span>
Xds = X(idx,idx,idx);
Yds = Y(idx,idx,idx);
Zds = Z(idx,idx,idx);
Hxds = Hx(idx,idx,idx) ./ Habs(idx,idx,idx);
Hyds = Hy(idx,idx,idx) ./ Habs(idx,idx,idx);
Hzds = Hz(idx,idx,idx) ./ Habs(idx,idx,idx);
</pre><pre class="language-matlab"><span class="comment">% show results</span>
quiver3(Xds, Yds, Zds, Hxds, Hyds, Hzds);
axis <span class="string">equal</span>;
</pre><h2 id="4">Input Argurments</h2><p><b>x</b> coordinates of positions at the field strength is calculated can be scalar, vector or matrix of coordinates. Must be same size as y and z.</p><p><b>y</b> coordinates of positions at the field strength is calculated can be scalar, vector or matrix of coordinates. Must be same size as x and z.</p><p><b>z</b> coordinates of positions at the field strength is calculated can be scalar, vector or matrix of coordinates. Must be same size as x and y.</p><p><b>m</b> magnetic dipole moment as 3 x 1 vector. The magnetic field strength is calculated with the same moment for all passed positions.</p><p><b>H0norm</b> scalar factor to imprint a field strength to the dipole field. Must be computed with the same magnitude of passed magnetic moment vector. Set 1 to disable imprinting.</p><h2 id="5">Output Argurments</h2><p><b>H</b> computed magnetic field strength at passed positions with related magnetic moment. If passed position is scalar H has size of 3 X 1 with its components in x, y and z dircetion. H(1) -&gt; x, H(2) -&gt; y and  H(3) -&gt; z. If passed positions are not scalar H has size of 3 x numel(x) with position relations in columns. So reshape rows to shapes of positions to keep orientation as origin.</p><h2 id="6">Requirements</h2><div><ul><li>Other m-files required: None</li><li>Subfunctions: mustBeEqualSize</li><li>MAT-files required: None</li></ul></div><h2 id="7">See Also</h2><div><ul><li><a href="generateDipoleRotationMoments.html">generateDipoleRotationMoments</a></li><li><a href="generateSensorArraySquareGrid.html">generateSensorArraySquareGrid</a></li><li><a href="computeDipoleH0Norm.html">computeDipoleH0Norm</a></li></ul></div><p>Created on June 11. 2019 by Thorben Sch&uuml;the. Copyright Thorben Sch&uuml;the 2019.</p><p>
<!--
Hidden Clutter.
Edited on Month DD. YYYY by Editor: Single line description.
Edited on November 11. 2020 by Tobias Wulf: Rewritten, compute as vector in xyz.
Edited on November 11. 2020 by Tobias Wulf: Compute with unit vector.
Edited on November 11. 2020 by Tobias Wulf: Add norming on rest position.
-->
</p><pre class="codeinput"><span class="keyword">function</span> [H] = computeDipoleHField(x, y, z, m, H0norm)
    <span class="keyword">arguments</span>
        <span class="comment">% validate position, can be any size but must be same size of</span>
        x <span class="typesection">(:,:,:) double {mustBeReal}</span>
        y <span class="typesection">(:,:,:) double {mustBeReal, mustBeEqualSize(x, y)}</span>
        z <span class="typesection">(:,:,:) double {mustBeNumeric, mustBeReal, mustBeEqualSize(y, z)}</span>
        <span class="comment">% validate magnetic moment as 3 x 1 vector</span>
        m <span class="typesection">(3,1) double {mustBeReal, mustBeVector}</span>
        <span class="comment">% validate norm factor as scalar</span>
        H0norm <span class="typesection">(1,1) double {mustBeReal}</span>
    <span class="keyword">end</span>

    <span class="comment">% unify positions to column vector or matrix of column vectors if positions</span>
    <span class="comment">% are not passed as column vectors or scalar, resulting size of position R</span>
    <span class="comment">% is 3 x length(X), a indication if is column vector is not needed because</span>
    <span class="comment">% x(:) is returning all content as column vector. Transpose to match shape.</span>
    r = [x(:), y(:), z(:)]';

    <span class="comment">% calculate the magnitude of all positions</span>
    rabs = sqrt(sum(r.^2, 1));

    <span class="comment">% calculate the the unit vector of all positions</span>
    rhat = r ./ rabs;

    <span class="comment">% calculate H-field of current magnetic moment for all passed positions</span>
    <span class="comment">% calculate constants in eqution once in the first bracket term, all vector</span>
    <span class="comment">% products in the second term and finially divide by related magnitude ^3</span>
    H = (H0norm / 4 / pi) * (3 * rhat .* (m' * rhat) - m) ./ rabs.^3;
<span class="keyword">end</span>

<span class="comment">% Custom validation function</span>
<span class="keyword">function</span> mustBeEqualSize(a,b)
    <span class="comment">% Test for equal size</span>
    <span class="keyword">if</span> ~isequal(size(a),size(b))
        eid = <span class="string">'Size:notEqual'</span>;
        msg = <span class="string">'X Y Z positions must be the same size and orientation.'</span>;
        throwAsCaller(MException(eid,msg))
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% computeDipoleHField
% Computes the magnetic field strength H of a dipole magnet dependent of
% position and magnetic moment and imprint a field strength magnitude on the
% resultating field by passing a norm factor which relates to the rest position
% of the dipole magnet. The resultating field strength has field components in
% x, y and z direction.
%
% The magnetic dipole moment w must be a column vector or shape
%
% $$\vec{m} = \left[ \matrix{m_x \cr m_y \cr m_z} \right]$$
%
% so that the magnetic moment corresponds to a position vector
%
% $$\vec{r} = \left[ \matrix{x \cr y \cr z} \right]$$
%
% with coordinates for x, y and z in 3D coordinate system which can be taken
% part of its unit vector and its magnitude.
%
% $$\vec{r} = \hat{r} \cdot |\vec{r}|$$
%
% It computes the field strenght at this position with the current magnetic
% moment for field compents in the same orientation.
%
% $$\vec{H}(\vec{r}) = \left[ \matrix{H_x \cr H_y \cr H_z} \right]$$
%
% The originally equation of the magnetic dipole is known as
%
% $$\vec{H}(\vec{r}) = \frac{\vec{B}(\vec{r})}{\mu_0}$$
%
% $$\vec{H}(\vec{r}) = \frac{1}{4\pi} \cdot
% \frac{3\vec{r}\cdot(\vec{m}^T\cdot\vec{r}) - \vec{m}\cdot|\vec{r}|^2}{|\vec{r}|^5}$$
%
% which can be simplified by putting in the unit vector of the position in into
% the equation.
%
% $$\vec{H}(\vec{r}) = \frac{1}{4\pi|\vec{r}|^3} \cdot
% \big(3\hat{r}\cdot(\vec{m}^T\cdot\hat{r}) - \vec{m}\big)$$
% 
% To imprint a certain field strength related to a rest position of the dipole
% the resulting field strength is multiplied with a norming factor. The factor
% must be computed with same magnitude of the magnetic dipole moments which is
% passed to this computation to get correct field strengths. To get fields
% without imprinting set the norming factor to 1.
%
% $$\vec{H}(\vec{r}) \cdot H_{0norm}$$
%
%
%% Syntax
%   H = computeDipoleHField(x, y, z, m, H0norm)
%
%
%% Description
% *H = computeDipoleHField(x, y, z, m, H0norm)* compute dipole field strength at
% passed position (x,y,z) with the magnetic dipole moment m. The resulting field
% strenght is a vector with components in x, y and z direction. A field strength
% norming is imprinted on a rest position computation and multiplied on the
% result by multiplying a norm factor to the field. The normfactor must be
% relate to the same magnitude of the magnetic dipole moment which is used here
% and correspond to the magnets rest position in defined distance of the magnets
% surface.
%
%
%% Examples
%   % compute a single point without norming
%   H = computeDipoleHField(1, 2, 3, [1; 0; 0], 1)
%
%   % compute a 3D grid of positions
%   x = linspace(-10, 10, 40);
%   y = linspace(10, -10, 40);
%   z = linspace(10, -10, 40);
%   [X, Y, Z] = meshgrid(x, y, z);
%
%   % allocate memory for field components in x,y,z
%   Hx = zeros(40, 40, 40);
%   Hy = zeros(40, 40, 40);
%   Hz = zeros(40, 40, 40);
%
%   % compute without norming for each z layer and reshape results into layer
%   % magnetic moments points in -x direction which implies north and south pole
%   % is in x direction and rotation axes in z
%   for i=1:40
%       H = computeDipoleHField(X(:,:,i),Y(:,:,i),Z(:,:,i),[-1;0;0],1);
%       Hx(:,:,i) = reshape(H(1,:),40,40);
%       Hy(:,:,i) = reshape(H(2,:),40,40);
%       Hz(:,:,i) = reshape(H(3,:),40,40);
%   end
%
%   % calculate magnitude in each point for better view the results
%   Habs = sqrt(Hx.^2+Hy.^2+Hz.^2);
%
%   % define a index to view only every 4th point for not overcrowded plot
%   idx = 1:4:40;
%
%   % downsample and norm
%   Xds = X(idx,idx,idx);
%   Yds = Y(idx,idx,idx);
%   Zds = Z(idx,idx,idx);
%   Hxds = Hx(idx,idx,idx) ./ Habs(idx,idx,idx);
%   Hyds = Hy(idx,idx,idx) ./ Habs(idx,idx,idx);
%   Hzds = Hz(idx,idx,idx) ./ Habs(idx,idx,idx);
%
%   % show results
%   quiver3(Xds, Yds, Zds, Hxds, Hyds, Hzds);
%   axis equal;
%
%
%% Input Argurments
% *x* coordinates of positions at the field strength is calculated can be
% scalar, vector or matrix of coordinates. Must be same size as y and z.
%
% *y* coordinates of positions at the field strength is calculated can be
% scalar, vector or matrix of coordinates. Must be same size as x and z.
%
% *z* coordinates of positions at the field strength is calculated can be
% scalar, vector or matrix of coordinates. Must be same size as x and y.
%
% *m* magnetic dipole moment as 3 x 1 vector. The magnetic field strength is
% calculated with the same moment for all passed positions.
%
% *H0norm* scalar factor to imprint a field strength to the dipole field. Must
% be computed with the same magnitude of passed magnetic moment vector. Set 1 to
% disable imprinting.
%
%
%% Output Argurments
% *H* computed magnetic field strength at passed positions with related magnetic
% moment. If passed position is scalar H has size of 3 X 1 with its components
% in x, y and z dircetion. H(1) -> x, H(2) -> y and  H(3) -> z. If passed
% positions are not scalar H has size of 3 x numel(x) with position relations in
% columns. So reshape rows to shapes of positions to keep orientation as origin.
%
%
%% Requirements
% * Other m-files required: None
% * Subfunctions: mustBeEqualSize
% * MAT-files required: None
%
%
%% See Also
% * <generateDipoleRotationMoments.html generateDipoleRotationMoments>
% * <generateSensorArraySquareGrid.html generateSensorArraySquareGrid>
% * <computeDipoleH0Norm.html computeDipoleH0Norm>
%
%
% Created on June 11. 2019 by Thorben Schüthe. Copyright Thorben Schüthe 2019.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on Month DD. YYYY by Editor: Single line description.
% Edited on November 11. 2020 by Tobias Wulf: Rewritten, compute as vector in xyz.
% Edited on November 11. 2020 by Tobias Wulf: Compute with unit vector.
% Edited on November 11. 2020 by Tobias Wulf: Add norming on rest position.
% REPLACE_WITH_DASH_DASH>
% </html>
%
function [H] = computeDipoleHField(x, y, z, m, H0norm)
    arguments
        % validate position, can be any size but must be same size of
        x (:,:,:) double {mustBeReal}
        y (:,:,:) double {mustBeReal, mustBeEqualSize(x, y)}
        z (:,:,:) double {mustBeNumeric, mustBeReal, mustBeEqualSize(y, z)}
        % validate magnetic moment as 3 x 1 vector
        m (3,1) double {mustBeReal, mustBeVector}
        % validate norm factor as scalar
        H0norm (1,1) double {mustBeReal}
    end
    
    % unify positions to column vector or matrix of column vectors if positions
    % are not passed as column vectors or scalar, resulting size of position R
    % is 3 x length(X), a indication if is column vector is not needed because
    % x(:) is returning all content as column vector. Transpose to match shape.
    r = [x(:), y(:), z(:)]';
    
    % calculate the magnitude of all positions
    rabs = sqrt(sum(r.^2, 1));
    
    % calculate the the unit vector of all positions
    rhat = r ./ rabs;
        
    % calculate H-field of current magnetic moment for all passed positions
    % calculate constants in eqution once in the first bracket term, all vector
    % products in the second term and finially divide by related magnitude ^3
    H = (H0norm / 4 / pi) * (3 * rhat .* (m' * rhat) - m) ./ rabs.^3;
end

% Custom validation function
function mustBeEqualSize(a,b)
    % Test for equal size
    if ~isequal(size(a),size(b))
        eid = 'Size:notEqual';
        msg = 'X Y Z positions must be the same size and orientation.';
        throwAsCaller(MException(eid,msg))
    end
end

##### SOURCE END #####
--></body></html>