
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: {extensions: ["mhchem.js"]},
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: true
            },
            CommonHTML: {minScaleAdjust: 110,},
            "HTML-CSS": {
                availableFonts: ["TeX"],
                scale: 110
            }
        });
        MathJax.Hub.Queue(["Rerender", MathJax.Hub], function () {window.status="finished"});
    </script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>sensorArraySimulation</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-01-10"><meta name="DC.source" content="sensorArraySimulation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>sensorArraySimulation</h1><!--introduction--><p>A spherical magnet is assumed to be used for stimulation of the sensor array. The far field of a spherical magnet can be approximately described by the magnetic field of a magnetic dipole. The magnetization of the sphere is assumed to be in y direction and the magnetic moment in rest position for 0&deg; points in x direction. The magnet must be defined in a way that its field lines or field strengths own gradients sufficiently strong enough in the distance to the sensor array and so the rotation of the magnet generates a small scattering of the bridge outputs in the individual sensor points in the array. That  all sensors in the array approximately perceive the same magnetic field gradients of the current rotation step and the sensors in the array run through approximately  equal circular paths in the characterization field. This means the sperical magnet is characterized by a favorable mating of sphere radius and a certain distance in rest position in which a sufficiently high field strength takes effect. Here are neglected small necessary distances which are demanded in standard automotive applications. The focus here is on to generate simulation datasets, which are uniform and valid for angle detection. The modelling of suitable small magnets is not taking place of the work.</p><p>A good working magnet is found emperical for H-field magnitudes of 200 kA/m and a distance from surface of 1 mm. See below figure of used magnet.</p><p>To change settings for simulation edit the config script and rerun it. To generate trainging and test data set use simulation script. It generates dataset for all position are known to TrainingOptions and TestOptions in config. Generate a set of dataset for one evaluation case. Evaluate datasets, save results for later clustering, edit config for next use case and rerun simulation.</p><p>The simulation bases on TDK TAS2141 "Rise" chracterization field. It has the widest linear plateau for corresponding Hx and Hy field strengths.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">See Also</a></li><li><a href="#2">simulateDipoleSquareSenorArray</a></li><li><a href="#3">computeDipoleHField</a></li><li><a href="#4">computeDipoleH0Norm</a></li><li><a href="#5">generateSensorArraySquareGrid</a></li><li><a href="#6">generateDipoleRotationMoments</a></li><li><a href="#7">rotate3DVector</a></li></ul></div><h2 id="1">See Also</h2><div><ul><li><a href="generateConfigMat.html">generateConfigMat</a></li><li><a href="generateSimulationDatasets.html">generateSimulationDatasets</a></li><li><a href="deleteSimulationDatasets.html">deleteSimulationDatasets</a></li></ul></div><h2 id="2">simulateDipoleSquareSenorArray</h2><p>Simulates a square sensor array with dipole magnet as stimulus for a certain setup of training or test options. Saves generated dataset to data/training or data/test.</p><h2 id="3">computeDipoleHField</h2><p>Computes the dipole field strength for meshgrids with additional abillity to imprint a certain field strength in defined radius on resulting field.</p><h2 id="4">computeDipoleH0Norm</h2><p>Computes a norm factor to imprint a magnetic field strength to magnetic dipole fields with same magnetic moment magnitude and constant dipole sphere radius on which the imprinted field strengt takes effect.</p><h2 id="5">generateSensorArraySquareGrid</h2><p>Generates a square sensor array grid in a 3D coordinate system with relative position to center of the system and an additional offset in z direction.</p><h2 id="6">generateDipoleRotationMoments</h2><p>Generates magnetic rotation moments to rotate a magnetic dipol in its z-axes with a certain tilt.</p><h2 id="7">rotate3DVector</h2><p>Rotates a vector with x-, y- and z-components in a 3D-coordinate system. Rotate one step of certain angles.</p><p>Created on November 04. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.</p><p>
<!--
Hidden Clutter.
Edited on November 04. 2020 by Tobias Wulf: Add rotate3DVector.
Edited on November 06. 2020 by Tobias Wulf: Add generateDipoleRotationMoments.
Edited on November 22. 2020 by Tobias Wulf: Add dipole computation functions.
Edited on November 25. 2020 by Tobias Wulf: Add simulation function for squar senor arrays.
Edited on December 02. 2020 by Tobias Wulf: Add simulation plots.
-->
</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% sensorArraySimulation
% A spherical magnet is assumed to be used for stimulation of the sensor array.
% The far field of a spherical magnet can be approximately described by the
% magnetic field of a magnetic dipole. The magnetization of the sphere is
% assumed to be in y direction and the magnetic moment in rest position for 0Â°
% points in x direction. The magnet must be defined in a way that its field
% lines or field strengths own gradients sufficiently strong enough in the
% distance to the sensor array and so the rotation of the magnet generates a
% small scattering of the bridge outputs in the individual sensor points in the
% array. That  all sensors in the array approximately perceive the same magnetic
% field gradients of the current rotation step and the sensors in the array run
% through approximately  equal circular paths in the characterization field.
% This means the sperical magnet is characterized by a favorable mating of
% sphere radius and a certain distance in rest position in which a sufficiently
% high field strength takes effect. Here are neglected small necessary distances
% which are demanded in standard automotive applications. The focus here is on
% to generate simulation datasets, which are uniform and valid for angle
% detection. The modelling of suitable small magnets is not taking place of
% the work.
%
% A good working magnet is found emperical for H-field magnitudes of 200 kA/m
% and a distance from surface of 1 mm. See below figure of used magnet.
%
% To change settings for simulation edit the config script and rerun it. To
% generate trainging and test data set use simulation script. It generates
% dataset for all position are known to TrainingOptions and TestOptions in
% config. Generate a set of dataset for one evaluation case. Evaluate datasets,
% save results for later clustering, edit config for next use case and rerun
% simulation.
%
% The simulation bases on TDK TAS2141 "Rise" chracterization field. It has
% the widest linear plateau for corresponding Hx and Hy field strengths.
%
%
%% See Also
%
% * <generateConfigMat.html generateConfigMat>
% * <generateSimulationDatasets.html generateSimulationDatasets>
% * <deleteSimulationDatasets.html deleteSimulationDatasets>
%
%
%% simulateDipoleSquareSenorArray
% Simulates a square sensor array with dipole magnet as stimulus for a certain
% setup of training or test options. Saves generated dataset to data/training or
% data/test.
%
%
%% computeDipoleHField
% Computes the dipole field strength for meshgrids with additional abillity to
% imprint a certain field strength in defined radius on resulting field.  
%
%% computeDipoleH0Norm
% Computes a norm factor to imprint a magnetic field strength to magnetic dipole
% fields with same magnetic moment magnitude and constant dipole sphere radius
% on which the imprinted field strengt takes effect.
%
%
%% generateSensorArraySquareGrid
% Generates a square sensor array grid in a 3D coordinate system with
% relative position to center of the system and an additional offset in z
% direction.
%
%
%% generateDipoleRotationMoments
% Generates magnetic rotation moments to rotate a magnetic dipol in its z-axes
% with a certain tilt.
%
%
%% rotate3DVector
% Rotates a vector with x-, y- and z-components in a 3D-coordinate system. Rotate
% one step of certain angles.
%
%
% Created on November 04. 2020 by Tobias Wulf. Copyright Tobias Wulf 2020.
%
% <html>
% <!REPLACE_WITH_DASH_DASH
% Hidden Clutter.
% Edited on November 04. 2020 by Tobias Wulf: Add rotate3DVector.
% Edited on November 06. 2020 by Tobias Wulf: Add generateDipoleRotationMoments.
% Edited on November 22. 2020 by Tobias Wulf: Add dipole computation functions.
% Edited on November 25. 2020 by Tobias Wulf: Add simulation function for squar senor arrays.
% Edited on December 02. 2020 by Tobias Wulf: Add simulation plots.
% REPLACE_WITH_DASH_DASH>
% </html>
%
##### SOURCE END #####
--></body></html>