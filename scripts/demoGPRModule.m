%% demoGPRModule
% This script demonstrates the use of gaussianProcessRegression module. The
% demonstartions shows single steps of use from initialization to optimization.
% For use generate a training and testdataset with corresponding position. So
% the sensor model is built on none diverging coordinates.
%
%
%% Requirements
% * Other m-files required: gaussianProcessRegression module files
% * Subfunctions: none
% * MAT-files required: data/config.mat, corresponding Training and Test dataset
%
%
%% See Also
% * <gaussianProcessRegression.html gaussianProcessRegression>
% * <initGPR.html initGPR>
% * <tuneGPR.html tuneGPR>
% * <optimGPR.html>
% * <generateConfigMat.html generateConfigMat>
%
%
% Created on February 25. 2021 by Tobias Wulf. Copyright Tobias Wulf 2021.
%
% <html>
% <!--
% Hidden Clutter.
% Edited on Month DD. YYYY by Editor: Single line description.
% -->
% </html>
%
%
%% Start Script, Load Config and Read in Datasets
% At first clear all variables from workspace, close all open figures and clean
% prompt. Then loads configuration from config.mat and try to load training and
% test datasets. Finally check datasets for corresponding coordinates. Loading
% the first available datasets in training and test dataset path.
clc;
disp('Start GPR module demonstration ...');
clearvars;
close all;

disp('Load config ...');
load config.mat PathVariables GPROptions;

disp('Search for datasets ...');
TrainFiles = dir(fullfile(PathVariables.trainingDataPath, 'Training*.mat'));
TestFiles = dir(fullfile(PathVariables.testDataPath, 'Test*.mat'));
assert(~isempty(TrainFiles), 'No training datasets found.');
assert(~isempty(TestFiles), 'No test datasets found.');

disp('Load first found datasets ...');
try
    TrainDS = load(fullfile(TrainFiles(1).folder, TrainFiles(1).name));
    TestDS = load(fullfile(TestFiles(1).folder, TestFiles(1).name));

catch ME
    rethrow(ME)
end

disp('Check dataset coordinates corresponds ...');
assert(all(TrainDS.Data.X == TestDS.Data.X, 'all'), 'Wrong X grid.');
assert(all(TrainDS.Data.Y == TestDS.Data.Y, 'all'), 'Wrong Y grid.');
assert(all(TrainDS.Data.Z == TestDS.Data.Z, 'all'), 'Wrong Z grid.');


%% Compute Means of Test Dataset as Comparing Root
% Compute mean sinoids and angular error by raw dataset values.
% offcos0 - cosine offset
% offsin0 - sine offset
% fcos0   - offset free and normed mean cosine from raw test values
% fsin0   - offset free and normed mean sine from raw test values
% frad0   - radius by mean sinoids
% fang0   - angles by mean sinoids compute with angle function in predDS
% AAED0   - Absolute Angular Error in Degrees by mean sinoids
offcos0 = mean2(TestDS.Data.Vcos);
offsin0 = mean2(TestDS.Data.Vsin);
fcos0 = zeros(TestDS.Info.UseOptions.nAngles, 1);
fsin0 = zeros(TestDS.Info.UseOptions.nAngles, 1);
for n = 1:TestDS.Info.UseOptions.nAngles
    fcos0(n) = mean2(TestDS.Data.Vcos(:,:,n));
    fsin0(n) = mean2(TestDS.Data.Vsin(:,:,n));
end
fcos0 = fcos0 - offcos0;
fsin0 = fsin0 - offsin0;
frad0 = sqrt(fcos0.^2 + fsin0.^2);
fang0 = sinoids2angles(fsin0, fcos0, frad0);
AAED0 = abs(TestDS.Data.angles' - fang0 * 180 / pi);


%% Create GPR Modles for Demonstartion
% Create three GPR Modles by the same base configuration to compare bare
% initilized modle with and optimized generated modle with same root of 
% configuration.
% Mdl1 - bare initilized model by configuration
% Mdl2 - optimized modle generated by the same configuration as for Mdl1 with
%        free tuning of variance enabled by changing the theta(1) to
%        not equal 1
disp('Create GPR modles ...');
Mdl1 = initGPR(TrainDS, GPROptions);
GPROptions.theta(1) = 0.9;
Mdl2 = optimGPR(TrainDS, TestDS, GPROptions, 0);


%% Prediction on Test Dataset
% Predict sinoids and angles on test dataset for each created GPR modle.
% fangX  - computed angle by predicted sinoids
% fradX  - computed radius by predicted sinoids
% fcosX  - predicted cosine
% fsinX  - predicted sine
% fcovX  - predictive variance
% sX     - standard deviation of prediction
% ciangX - 95% confidence interval for angles
% ciradX - 95% confidence interval for radius
[fang1, frad1, fcos1, fsin1, fcov1, s1, ciang1, cirad1] = predDS(Mdl1, TestDS);
[fang2, frad2, fcos2, fsin2, fcov2, s2, ciang2, cirad2] = predDS(Mdl2, TestDS);



%% Compute Losses and Errors on Test Dataset
% Compute the loss and error on test dataset for each created GPR modle.
% AAEDX - Absolute Angular Error in Degrees
% SLLAX - Squared Log Loss Angular
% SLLRX - Squared Log Loss Radius
% SEAX  - Squared Error Angular
% SERX  - Squared Error Radius
% SECX  - Squared Error Cosine
% SESX  - Squared Error Sine
[AAED1, SLLA1, SLLR1, SEA1, SER1, SEC1, SES1] = lossDS(Mdl1, TestDS);
[AAED2, SLLA2, SLLR2, SEA2, SER2, SEC2, SES2] = lossDS(Mdl2, TestDS);


%% Plot Area and Expand Modle Results

figure();
tiledlayout(3,2);

nexttile;
plot(Mdl1.Ky);
hold on;
plot(1:Mdl1.N, Mdl1.Ky(floor(Mdl1.N/2)+1,:), 'kx-.', 'LineWidth', 1.5);
yline(mean2(Mdl1.Ky), 'k')
xlim([1, Mdl1.N]);
ylim([min(Mdl1.Ky, [], 'all'), max(Mdl1.Ky, [], 'all')]);

nexttile;
imagesc(Mdl1.Ky);
hold on;
plot(1:Mdl1.N, (floor(Mdl1.N/2)+1) * ones(1, Mdl1.N), 'kx-.', 'LineWidth', 1.5);
colorbar;

nexttile;
plot(Mdl2.Ky);
hold on;
plot(1:Mdl2.N, Mdl2.Ky(floor(Mdl2.N/2)+1,:), 'kx-.', 'LineWidth', 1.5);
xlim([1, Mdl2.N]);
ylim([min(Mdl2.Ky, [], 'all'), max(Mdl2.Ky, [], 'all')]);

nexttile;
imagesc(Mdl2.Ky);
hold on;
plot(1:Mdl2.N, (floor(Mdl2.N/2)+1) * ones(1, Mdl2.N), 'kx-.', 'LineWidth', 1.5);
colorbar;

% nexttile;
% plot(Mdl3.Ky);
% hold on;
% plot(1:Mdl3.N, Mdl3.Ky(floor(Mdl3.N/2)+1,:), 'kx-.', 'LineWidth', 1.5);
% xlim([1, Mdl3.N]);
% ylim([min(Mdl3.Ky, [], 'all'), max(Mdl3.Ky, [], 'all')]);
% 
% nexttile;
% imagesc(Mdl3.Ky);
% hold on;
% plot(1:Mdl3.N, (floor(Mdl3.N/2)+1) * ones(1, Mdl3.N), 'kx-.', 'LineWidth', 1.5);
% colorbar;


%%
figure()
plot(ciang1-fang1)
hold on
plot(ciang2-fang2)
% plot(ciang3-fang3)

%%
figure()
plot(cirad1-frad1)
hold on
plot(cirad2-frad2)
% plot(cirad3-frad3)


%%
figure()
plot(AAED0)
hold on
plot(AAED1)
plot(AAED2)
% plot(AAED3)
ylim([0 4])
legend


%%
figure()
plot(SLLA1, 'x-.')
hold on
plot(SLLA2, 'x-.')
% plot(SLLA3, 'x-.')
legend

